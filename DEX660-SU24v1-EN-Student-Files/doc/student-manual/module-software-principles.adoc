// Copyright (C) MuleSoft, Inc. All rights reserved. http://www.mulesoft.com
//
// The software in this package is published under the terms of the
// Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License,
// a copy of which has been included with this distribution in the LICENSE.txt file.
[[module-software-principles]]
:sectnums!:
== {M-c} {mct}: Applying basic software engineering principles

{InThisMYou} apply these essential software engineering principles to a {MApp} and its {MVN} build: repeatability through convention and automation, security through encryption, separation of concerns, and non-redundancy of code and configuration.

{MOBJ}

* Apply and follow coding conventions.
* Securely parameterize a {MApp} and its {MVN} build for different runtime environments.
* Deploy to {CH} from a {MVN} build.

//....................................................................................................................
<<<
:sectnums!:
[[wt-begin-121]]
=== {WT-c} {mct}-{counter:wtct}: Apply and follow coding conventions

The code for {CIPAPII} at this point is essentially that generated by {Studio}. There are two fundamentally different approaches for dealing with generated code: One approach is to keep generated code clearly separate from hand-written code, making as few changes as possible to generated code, and applying coding conventions only to hand-written code. The other approach is to see code generation as a shortcut to writing "normal" code, and consequently treat generated code the same way as hand-written code, applying the same coding conventions to all code. It is this latter approach that {AA} follows and that you start enforcing in this {WT}.

{InThisWTYou} establish the following basic coding conventions (a sub-set of those given in <<module-coding-conventions>>), apply them to {CIPAPII}, and lay the foundation for following them in all future development:

. Don't repeat yourself: avoid duplication.
. Abbreviate when space is constrained: SAPI=System API, PAPI=Process API, EAPI=Experience API.
. For {MApps}:
.. {Studio} project name = {MVN} artifact ID = {MVN} project name, for example {CIPAPII}.
.. Formatting: standard Eclipse XML editor settings with width 140 characters and do not format comments.
.. Flows and global error handlers: for example {CIByPNRFlow} or {ApiErrorHandler}.
.. Global element names: for example apiHttpListenerConfig.
.. {MFlowConfs}: {GlobalXml}, {ApiXml}, {MainXml}, {ErrorXml}, {HealthXml}.

You will add to these basic coding conventions in later {WTs} as and when needed (see <<module-coding-conventions>>).

For conciseness, all {DocNameAttr} attributes are omitted from {MFlow} code shown in this document.

{YouWill}

* <<Apply coding conventions to a {Studio}-generated {APII},Apply these coding conventions retroactively to {CIPAPII}>>.
* <<Deploy a reusable template to {Exchange},Deploy a reusable template to {Exchange}>>.


==== Solution file
{YouSeeSol} {SolDir121}.

==== Starting file
{YouMightNeedStarter} {SolDir112}.

==== Apply coding conventions to a {Studio}-generated {APII}

{InThisWTSecYou} refactor {CIPAPII}: rename global configuration elements and move them to {GlobalXml}, rename global {EHandlers} and move them to {ErrorXml}, extract all main integration logic to flows in {MainXml}, and separate flows related to exposing {CIPAPI} in {ApiXml}.

. *Rename {MFlowConf}:* In {Studio}, rename your only {MFlowConf} *{ApiXml}*.
. *Rename global elements:* In *{ApiXml}*, change all global element names to follow the naming convention:
+
--
.{ApiXml} of {CIPAPII}
[source]
----
<tls:context name="apiTLSContext" />
<http:listener-config name="apiHttpListenerConfig" />
<apikit:config name="apiConfig" />
----

{NOTE} _It is best to do this be search-replace so as not to miss any references to the old names, for example to the {AKitConf} name from flow names that process {APIInvs}._
--
+
. *Move global elements:* Move all global elements from {ApiXml} to *{GlobalXml}*; only {MFlows} remain in {ApiXml}.
+
--
{NOTE} _The {GlobalXml} file only contains global configuration elements that are not {EHandlers}._

{NOTE} _To avoid XML namespace issues entirely, consider copying {ApiXml} to {GlobalXml} and then deleting unwanted XML elements from both files._
--
+
. *Extract and move {EHandlers}:* In the *{StudioFlowEdXML}*, from *{ApiXml}* extract the two local {EHandlers} in the {Studio}-generated {MFlows} *{ApiMainFlow}* and *{ApiConsoleFlow}* into two global {EHandlers} called *{ApiErrorHandler}* and *{ApiConsoleErrorHandler}*, respectively, in *{ErrorXml}*:
+
--
.{ErrorXml} of {CIPAPII}
[source]
----
<error-handler name="api-error-handler">
  ...
</error-handler>

<error-handler name="api-console-error-handler">
  ...
</error-handler>
----

.{ApiXml} of {CIPAPII}
[source]
----
<flow name="api-main">
  ...
  <error-handler ref="api-error-handler" />
</flow>

<flow name="api-console">
  ...
  <error-handler ref="api-console-error-handler" />
</flow>
----

{NOTE} _The {ErrorXml} file only contains global {EHandlers}._

{NOTE} _The {EHandler} references are currently neither visible nor editable in the {StudioFlowEdVis}._

{NOTE} _To avoid XML namespace issues entirely, consider copying {ApiXml} to {ErrorXml} and then deleting unwanted XML elements from both files._

{NOTE} _Currently, the {AKit}-generated {ApiErrorHandler} does not contain a catch-all {EHandler}: this is a shortcoming that you will correct in a later {WT}._
--
+
// TODO: move addition of catch-all error handler to api-error-handler to here from (currently) WT 4-3 step 13
. *Extract and move main flows:* In *{ApiXml}*, using the {StudioFlowEdVis}, locate the  two {MFlows}  generated by {AKit} to process the two HTTP requests and use the *extract to flow* refactoring to extract (only) the setting of the payload (the last {TMComp} in each flow) to two new private flows *{CIByPNRFlow}* and *{PaymtApprByPNRFlow}* in *{MainXml}*, such that they are called by {FlowRef} elements from the request processing flows in {ApiXml}; you will extend these extracted flows in future {WTs} to perform the main integration logic of {CIPAPI}:
+
--
.{ApiXml} of {CIPAPII}
[source]
----
<flow name="put:...">
  ...
  <flow-ref name="check-in-by-pnr" />
</flow>

<flow name="put:...">
  ...
  <flow-ref name="payment-approval-by-pnr" />
</flow>
----

.{MainXml} of {CIPAPII}
[source]
----
<flow name="check-in-by-pnr">
  <ee:transform>
    <ee:message>
      <ee:set-payload>...</ee:set-payload>
    </ee:message>
  </ee:transform>
</flow>

<flow name="payment-approval-by-pnr">
  <ee:transform>
    <ee:message>
      <ee:set-payload>...</ee:set-payload>
    </ee:message>
  </ee:transform>
</flow>
----

{NOTE} _The {MFlows} in {MainXml} are now essentially pure integration logic independent of the fact that this logic is exposed via an {API}, whereas the latter aspect is handled by the {MFlows} in {ApiXml}._

{NOTE} _It is good practice to set the {DocNameAttr} attribute of {FlowRef} elements to the name of the flow being invoked (see <<module-coding-conventions>>). But this document omits all {DocNameAttr} attributes for conciseness._

{NOTE} _Each {MFlow} is encapsulated and can be referenced by many calling {MFlows}. Therefore it is necessary to define the interface of each invokable {MFlow} via its metadata. This interface can be left implicit, set manually on each {MFlow}, or set via the Metadata assistant when using the extract to flow option in the {StudioFlowEdVis}._

{NOTE} _The Metadata assistant automatically detects the actual metadata of your existing {MFlow} and enables you to propagate the existing metadata to the {MFlow} you are referencing._

{NOTE} _Once the metadata is defined for the child {MFlow}, it can no longer be automatically updated if you modify the actual metadata in the calling parent {MFlow}._

{NOTE} _Using the Metadata assistant encourages a coding style of developing large self-contained {MFlows} and refactoring over time into smaller, reusable {MFlows}. This coding style is supplemented by unit testing to make sure existing code doesn’t break when later refactored. You will learn how to unit test {MApp}s in later {WTs}._
--
+
. *{RUN}* Confirm that the {MApp} still starts up without errors in {Studio}.

==== Deploy a reusable template to {Exchange}

{InThisWTSecYou} deploy {CIPAPII} as a reusable project template to {Exchange} — allowing other developers to use this canonical project to bootstrap other {API} projects in future.

[start=7]
. *Bootstrap {CIPAPIITemplate}:* Copy *{CIPAPII}* to *{CIPAPIITemplate}* in the workspace directory:
+
--
[source,bash,subs="attributes+"]
----
cd ${WSEnvVar}
cp -R {CIPAPII} {CIPAPIITemplate}
----
--
+
. *Import into {Studio}:* In {Studio}, import the {CIPAPIITemplate} project as a {MApp}, without copying it into the workspace, because it is already there; confirm that the import succeeded.
. *Modify {MVN} coordinates:* Update {POMXml} adapting the *artifactId* and *name* to the new project name: {CIPAPIITemplate} and increasing the *version* to a non-SNAPSHOT release version.
+
--
.{POMXml} of {CIPAPIITemplate}
[source,subs="attributes+"]
----
<project>
  <artifactId>check-in-papi-template</artifactId>
  <version>1.0.0</version>
  <name>check-in-papi-template</name>
  ...
</project>
----

{NOTE} _Although {Exchange} supports SNAPSHOT versions for template projects, at the time of writing {Studio} does not. You can however use the {EMMP} which will be discussed in a later {WT}._
--
+
. *Create Category metadata*: In *{Exchange}*, navigate to *Settings* and create a new category: *Tier* with values for each API layer: *System Tier*, *Process Tier* and *Experience Tier*.
+
--
{NOTE} _Categories allow you to organize {Exchange} assets into groups to improve asset browsing and discovery._
--
+
. *Deploy template to {Exchange}:* In {Studio}, from the Anypoint menu: *Publish to Exchange*, choosing *Template* as the project type and click *Next*.
. *Set metadata*: From the next screen, add a tag: *check-in*, and add the *Process Tier* category created previously.
+
--
{NOTE} _You must be *logged-in* with an account of your {APOrg} to be able to deploy to your {Exchange}._
--
+
. *Study {POMXml}:* Notice the addition of the properties for the various metadata:
+
--
.{POMXml} of {CIPAPIITemplate}
[source,subs="attributes+"]
----
<project>
  <artifactId>check-in-papi-template</artifactId>
  <version>1.0.0</version>
  <packaging>mule-application</packaging>
  <name>check-in-papi-template</name>
  ...
  <properties>
    <tags>check-in</tags>
    <categories>[{"key":"Tier","value":"Process Tier"}]</categories>
  </properties>
</project>
----

{NOTE} _You will look more in-detail at deploying various asset types to {Exchange} with {MVN} in a later {WT}._
--
+
. *Study {Exchange} asset:* Navigate to your {Exchange}, download the asset jar for {CIPAPIITemplate}, and extract the contents. Study the {POMXml} file and notice the *{MMP} configuration* is configured to create an artifact with {MVNClassElem} *{MTemplateClassifier}*:
+
--
.{POMXml} of {CIPAPIITemplate}
[source,subs="attributes+"]
----
<project>
  <artifactId>check-in-papi-template</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>mule-application</packaging>
  <name>check-in-papi-template</name>

  ...
 <plugin>
    <groupId>org.mule.tools.maven</groupId>
    <artifactId>mule-maven-plugin</artifactId>
    <version>${mule.maven.plugin.version}</version>
    <extensions>true</extensions>
    <configuration>
      <classifier>mule-application-template</classifier>
    </configuration>
  </plugin>
</project>
----
{NOTE} _This configuration is not automatically added your {POMXml}, you will need to manually add this configuration if you intend to deploy the template via {MVN} outside of {Studio}._

{NOTE} _You will look more in-detail at deploying various asset types to {Exchange} with {MVN} in a later {WT}._
--


:sectnums:
//....................................................................................................................

//....................................................................................................................
<<<
:sectnums!:
[[wt-begin-122]]
=== {WT-c} {mct}-{counter:wtct}: Remove redundancy

When creating the {CIPAPII} {MApp} in the previous {WT}, you have hard-coded all configuration values directly in the {MApp} source code. Furthermore, the {MApp} utilizes a {MVN} build configuration generated by {Studio}, which also contains configuration values that partially overlap with values hard-coded in the {MApp} source code.

{InThisWTYou} identify all configuration values of {CIPAPII} and its {MVN} build and extract them into suitable configuration files of the {MVN} build and in {CIPAPII} to reduce redundancy and improve maintainability and reuse.

{YouWill}

* <<Extract {MApp} configuration values into a properties file>>.
* <<Remove configuration redundancy using {MVN} resource filtering>>.
* <<Remove build redundancy and increase build reproducibility by introducing a {PPOM}>>.
* <<Centralize {MVN} dependency and plugin versions in a {BOM}>>.

==== Solution file
{YouSeeSol} {SolDir122}.

==== Starting file
{YouMightNeedStarter} {SolDir121}.

==== Extract {MApp} configuration values into a properties file

{InThisWTSecYou} extract all configuration values from the {CIPAPII} {MApp} code into a single configuration file {PropYaml}.

. *Identify config values:* In {Studio}, study the {MFlowConfs} of {CIPAPII} and identify all configuration values.
+
{NOTE} _Consider all values that might change over time or that might differ between environments to be configuration values._
+
. *Study {AKit} api attribute:* Identify the constituent parts of the {AKitConf} api attribute and determine their *meaning*:
+
--
.{GlobalXml} of {CIPAPII}
[source]
----
<apikit:config api="resource::6ebe1206-ddb1-4f2a-b06e-dca3244ebbad:check-in-papi:1.0.0:oas:zip:api.json"
----

{NOTE} _Some of these values will be different for you. This remains true for the entire {WT} and will not be repeated._
--
+
. *Copy config values to props file:* Create a new file *{PropYaml}* in *{SrcMR}* and add all configuration values, suitably named and organized:
+
--
.{PropYaml} of {CIPAPII}
[source,yaml]
----
api:
  groupId:      "6ebe1206-ddb1-4f2a-b06e-dca3244ebbad"
  artifactId:   "check-in-papi"
  version:      "1.0.0"
  spec: "resource::${api.groupId}:${api.artifactId}:${api.version}:oas:zip:api.json"
  majorVersion: "v1"
  id:           "15678353"

https:
  port: "8081"

tls.keystore:
  type:        "pkcs12"
  path:        "check-in-papi.p12"
  alias:       "server"
  password:    "mule12345"
  keyPassword: "mule12345"
----

{NOTE} _Break-down the complicated api.spec value into its constituent parts, as shown here._
--
+
. *Read props file:* Near the top of *{GlobalXml}*, read *{PropYaml}*:
+
--
.{GlobalXml} of {CIPAPII}
[source]
----
<configuration-properties file="properties.yaml" />
----
--
+
. *Reference config props:* Replace all configuration values with references to the corresponding properties:
+
--
.{GlobalXml} of {CIPAPII}
[source]
----
<tls:context name="apiTLSContext">
  <tls:key-store type="${tls.keystore.type}" path="${tls.keystore.path}"
    password="${tls.keystore.password}"
    keyPassword="${tls.keystore.keyPassword}"
    alias="${tls.keystore.alias}" />
</tls:context>

<http:listener-config name="apiHttpListenerConfig">
  <http:listener-connection host="0.0.0.0"
    protocol="HTTPS" port="${https.port}" tlsContext="apiTLSContext" />
</http:listener-config>

<apikit:config name="apiConfig" api="${api.spec}"
  outboundHeadersMapName="outboundHeaders"
  httpStatusVarName="httpStatus" />

<api-gateway:autodiscovery apiId="${api.id}" flowRef="api-main" />
----

.{ApiXml} of {CIPAPII}
[source]
----
<flow name="api-main">
  <http:listener config-ref="apiHttpListenerConfig"
    path="/api/${api.majorVersion}/*">
    ...
  </http:listener>
  ...
</flow>

<flow name="api-console">
  <http:listener config-ref="apiHttpListenerConfig"
    path="/console/${api.majorVersion}/*">
    ...
  </http:listener>
  ...
</flow>
----

{NOTE} _You use the reserved property {HTTPSPortProp} for the port to expose the {API} on which is overriden by {CH}. The value is assigned automatically by the platform services when deployed to {CH}. {CH2} assigns 8081 as the value, but you can use a different value locally if needed._
--
+
. *{RUNINV}* Run the {MApp} from {Studio} and invoke the {API} as before; this should return a HTTP 200 OK response and the hard-coded response body:
+
include::{LocalCurlCheckinSmithLocal}[]

==== Remove configuration redundancy using {MVN} resource filtering

{InThisWTSecYou} introduce {MVN} resource filtering to {CIPAPII} such that configuration values that must be defined in the {MVN} {POM} do not have to be repeated in the {MApp} code.

Resource filtering is a feature of the standard {MRP}. A more appropriate name would be "resource preprocessing", because it consists in references to {MVN} property names in resource files being replaced with the values of these properties as defined in the {MVN} {POM}.

[start=7]
. *Detect build and configuration repetition:* Inspect *{POMXml}* in general and in particular the {MVN} dependency on the {CIPAPI} {APISpec} in {OAS} format; note the duplication with *{PropYaml}*:
+
--
.{POMXml} of {CIPAPII}
[source]
----
<dependency>
  <groupId>6ebe1206-ddb1-4f2a-b06e-dca3244ebbad</groupId>
  <artifactId>check-in-papi-app</artifactId>
  <version>1.0.0</version>
  <classifier>oas</classifier>
  <type>zip</type>
</dependency>
----

.{PropYaml}
[source,yaml]
----
api:
  groupId:      "6ebe1206-ddb1-4f2a-b06e-dca3244ebbad"
  artifactId:   "check-in-papi"
  version:      "1.0.0"
----

{NOTE} _This duplication means that every change to the {APISpec} being implemented by this {MApp} requires a synchronized change to {POMXml} and {PropYaml}._
--
+
. *Configure {MRP} resource filtering:* In {POMXml}, add to the *{MVNBuildElem}* element configuration for the standard {MRP} to perform {MVN} resource filtering of files in *{SrcMR}* and *{SrcTR}*, excluding known binary files:
+
--
.{POMXml} of {CIPAPII}
[source,subs="attributes+"]
----
<build>
  <resources>
    <resource>
      <directory>src/main/resources</directory>
      <filtering>true</filtering>
    </resource>
  </resources>
  <testResources>
    <testResource>
      <directory>src/test/resources</directory>
      <filtering>true</filtering>
    </testResource>
  </testResources>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-resources-plugin</artifactId>
      <version>{MRPVersion}</version>
      <configuration>
        <nonFilteredFileExtensions>
          <nonFilteredFileExtension>p12</nonFilteredFileExtension>
          <nonFilteredFileExtension>crt</nonFilteredFileExtension>
          <nonFilteredFileExtension>pem</nonFilteredFileExtension>
        </nonFilteredFileExtensions>
      </configuration>
    </plugin>
    ...
  </plugins>
<build>
----

{NOTE} _Merge the above into the existing {MVNBuildElem} element._

{NOTE} _If binary files were not excluded they would garbled by the filtering process._

{NOTE} _The {MRP} is a standard {MVN} plugin and unrelated to {MS}._
--
+
. *Add {MVN} props:* Add to the *{MVNPropElem}* element the configuration properties common to {POMXml} and {PropYaml}, copying their values from the {MVNDepsElem} section:
+
--
.{POMXml} of {CIPAPII}
[source]
----
<api.groupId>6ebe1206-ddb1-4f2a-b06e-dca3244ebbad</api.groupId>
<api.artifactId>check-in-papi</api.artifactId>
<api.version>1.0.0</api.version>
----

{NOTE} _{MVN} resource filtering replaces references to {MVN} properties in resource files with their values defined in the {MVN} build configuration, such as in {POMXml}._
--
+
. *Reference props in build:* Change the {MVN} dependency on the {CIPAPI} to use these properties:
+
.{POMXml} of {CIPAPII}
[source]
----
<dependency>
  <groupId>${api.groupId}</groupId>
  <artifactId>${api.artifactId}</artifactId>
  <version>${api.version}</version>
  <classifier>oas</classifier>
  <type>zip</type>
</dependency>
----
+
. *Reference props in config:* In *{PropYaml}*, similarly replace the values with references to these {MVN} properties:
+
--
.{PropYaml} of {CIPAPII}
[source,yaml]
----
api:
  groupId:      "${api.groupId}"
  artifactId:   "${api.artifactId}"
  version:      "${api.version}"
----

{NOTE} _{MVN} resource filtering replaces these property references with their values during the process-resources and process-test-resources life-cycle phases of the {MVN} build._
--
+
. *{RUNINV}* Run the {MApp} from {Studio} and invoke the {API} as before; this should return an HTTP 200 OK response.
. *Study filtered props file:* Compare the filtered (pre-processed) contents of *{PropYaml}* in *{TargetClassesDir}* to the source in {SrcMR}.
+
{NOTE} _If {TargetClassesDir} does not exist then briefly run the {MApp} in {Studio}, as this performs a {MVN} build. Or you can simply run a {MVN} build from a {CLI}, as will be done in later {WTs}._

[[wt2-2-introduce-ppom]]
==== Remove build redundancy and increase build reproducibility by introducing a {PPOM}

{InThisWTSecYou} extract all {MVN} build configuration that is not specific to {CIPAPII} from {POMXml} into a reusable {PPOM} within its own directory {PPOMXml}. You then transform {POMXml} into a {CPOM} of {PPOMXml}.

[start=14]
. *Identify reusable build config:* In *{POMXml}* and identify the configuration that is likely to be the same across related {MApps}.
+
{NOTE} _This includes the versions of {MVN} dependencies and {MVN} plugins, the configuration of plugins like the {MMP} and {MRP}, the resource filtering configuration, and the declaration (location) of {MVN} repositories from which to download dependencies._
+
. *Bootstrap {PPOM}:* Copy *{POMXml}* to *{PPOMXml}* in the parent directory:
+
--
[source,bash,subs="attributes+"]
----
cd ${WSEnvVar}
mkdir {PPOMDir}
cp {CIPAPII}/{POMXml} {PPOMXml}
----

{NOTE} _Typically, {PPOMs} are located in the parent directory of a {MVN} project. Because a {PPOM} is not related to a specific project, this approach is only viable if a monorepository is used, that is, if all related projects are located in the same source code (Git) repository <<Ref14>>. Then {PPOMs} can also be located in that monorepo, in a parent directory of the {MVN} projects. This is the approach taken by {AA}._

{NOTE} _If every project is maintained in its own repository — the opposite of a monorepo, sometimes called polyrepository or multirepository — then {PPOMs} are typically also maintained in distinct repos. Because the relative filesystem location of these {PPOMs} to the {MVN} projects that use them can then no longer be guaranteed, {PPOMs} must in this case be installed in a {MVN} repository and loaded from there._
--
+
. *Update dependencies:* In *{PPOMXml}* update if necessary the versions of these dependencies: *{MMP}* to {MMPVersion}, {AKit} to {AKitVersion}, and {HTTPConn} to {HTTPConnVersion}.
. *Turn into {PPOM}:* Change {PPOMXml} into a {PPOM} by adapting its {MVNCoords} including setting the groupId to your {APOrg} ID and retaining only build configuration common to similar {MApps}, wrapping {MVNDepsElem} into *{MVNDepMgmtElem}*, and wrapping {MVNPlugElem} into *{MVNPlugMgmtElem}*, and also introducing an additional *property* for the *{MR} version*:
+
--
.{PPOMXml} (outline)
[source,subs="attributes+"]
----
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>your-AP-organization-id</groupId>
  <artifactId>solutions-parent-pom</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <name>solutions-parent-pom</name>

  <properties>
    ...
    <app.runtime.semver>{MRSemVersion}</app.runtime.semver>
    <app.runtime>{MRVersion}</app.runtime>
    ...
  </properties>

  <build>
    <resources>...</resources>
    <testResources>...</testResources>
    <pluginManagement>
      <plugins>...</plugins>
    </pluginManagement>
  </build>

  <dependencyManagement>
    <dependencies>...</dependencies>
  </dependencyManagement>

  <repositories>...</repositories>
  <pluginRepositories>...</pluginRepositories>
</project>
----

.{PPOMXml} (more detail)
[source,subs="attributes+"]
----
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>your-AP-organization-id</groupId>
  <artifactId>solutions-parent-pom</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <name>solutions-parent-pom</name>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>
      UTF-8
    </project.reporting.outputEncoding>
    <app.runtime.semver>{MRSemVersion}</app.runtime.semver>
    <app.runtime>{MRVersion}</app.runtime>
    <mule.maven.plugin.version>{MMPVersion}</mule.maven.plugin.version>
  </properties>

  <build>
    <resources>
      <resource>
        <directory>src/main/resources</directory>
        <filtering>true</filtering>
      </resource>
    </resources>
    <testResources>
      <testResource>
        <directory>src/test/resources</directory>
        <filtering>true</filtering>
      </testResource>
    </testResources>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-resources-plugin</artifactId>
          <version>{MRPVersion}</version>
          <configuration>
            <nonFilteredFileExtensions>
              <nonFilteredFileExtension>p12</nonFilteredFileExtension>
              <nonFilteredFileExtension>crt</nonFilteredFileExtension>
              <nonFilteredFileExtension>pem</nonFilteredFileExtension>
            </nonFilteredFileExtensions>
          </configuration>
        </plugin>
        <plugin>
          <groupId>org.mule.tools.maven</groupId>
          <artifactId>mule-maven-plugin</artifactId>
          <version>${mule.maven.plugin.version}</version>
          <extensions>true</extensions>
          <configuration>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.mule.connectors</groupId>
        <artifactId>mule-http-connector</artifactId>
        <version>{HTTPConnVersion}</version>
        <classifier>mule-plugin</classifier>
      </dependency>
      <dependency>
        <groupId>org.mule.modules</groupId>
        <artifactId>mule-apikit-module</artifactId>
        <version>{AKitVersion}</version>
        <classifier>mule-plugin</classifier>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <repositories>
    <repository>
      <id>anypoint-exchange-v3</id>
      ...
    </repository>
    <repository>
      <id>mulesoft-releases</id>
      ...
    </repository>
  </repositories>
  <pluginRepositories>
    <pluginRepository>
      <id>mulesoft-releases</id>
      ...
    </pluginRepository>
  </pluginRepositories>
</project>
----

{NOTE} _This {POM} uses the {APOrg} ID for the groupId, as this is a prerequisite for publishing to {Exchange}, which you will do later._

{NOTE} _The {Exchange} Maven Facade API does not support dynamic parameters within groupIds such as ${aa.ap.org.id} and it requires the value to be the hardcoded {APOrg} ID._

{NOTE} _The {Exchange} Maven Facade API does not support dynamic parameters, such as setting the asset version to 1.0.${revision}._

{NOTE} _In rare circumstances, such as when a hotfix to a {MR} is released, there is a need to distinguish between the full version of the runtime ({MRVersion}) and the simplified version of that same runtime ({MRSemVersion}, which follows semantic versioning (semver) rules). You anticipate this need by defining two separate {MVN} properties for the {MR} version._

{NOTE} _By wrapping {MVNDepsElem} into {MVNDepMgmtElem} you default the version of these dependencies for all child projects, while allowing child projects to bring in these dependencies as needed._

{NOTE} _By defining the {MMP} inside {MVNPlugMgmtElem} you default the version and configuration of this plugin for all child projects, while allowing child projects to execute this plugins as needed. {MApps} will always want to execute this plugin, while other {MVN} projects will not._

{NOTE} _By defining the {MRP} inside {MVNPlugMgmtElem} you default the version and configuration of this plugin for all child projects. But this is a standard {MVN} plugin that is always executed during a normal {MVN} build, so child projects do not have to explicitly request execution of this plugin, like they have to do for the {MMP}._

{NOTE} _This {PPOM} does not impose any actual dependencies or plugin executions on its {CPOMs}._

{NOTE} _Do not manage the dependency on {CIPAPII} in the {PPOM}: there is currently no value in doing so. Shortly you will simply define the un-managed dependency in {CIPAPII}'s {POMXml}._

{NOTE} _Do not manage the dependency on the {SockConn} in the {PPOM}, as this is added automatically as a transitive dependency of the {HTTPConn}. Shortly you will also remove the {SockConn} from {CIPAPII}'s {POMXml}._
--
+
. *Turn {POM} into {CPOM}:* Change *{POMXml}* into a {CPOM} by defining *{PPOMXml}* as its {PPOM} and removing all configuration inherited from that {PPOM}, such as dependency versions:
+
--
.{POMXml} of {CIPAPII}
[source]
----
<project>
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>your-AP-organization-id</groupId>
    <artifactId>solutions-parent-pom</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <relativePath>../parent-pom/pom.xml</relativePath>
  </parent>
  <groupId>a63e6d25-8aaf-4512-b36d-d91b90a55c4a</groupId>
  <artifactId>check-in-papi-app</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>mule-application</packaging>
  <name>check-in-papi</name>

  <properties>
    <api.groupId>6ebe1206-ddb1-4f2a-b06e-dca3244ebbad</api.groupId>
    <api.artifactId>check-in-papi</api.artifactId>
    <api.version>1.0.0</api.version>
  </properties>

  <build>
    <plugins>
      <plugin>
        <groupId>org.mule.tools.maven</groupId>
        <artifactId>mule-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
      <groupId>${api.groupId}</groupId>
      <artifactId>${api.artifactId}</artifactId>
      <version>${api.version}</version>
      <classifier>oas</classifier>
      <type>zip</type>
    </dependency>
    <dependency>
      <groupId>org.mule.connectors</groupId>
      <artifactId>mule-http-connector</artifactId>
      <classifier>mule-plugin</classifier>
    </dependency>
    <dependency>
      <groupId>org.mule.modules</groupId>
      <artifactId>mule-apikit-module</artifactId>
      <classifier>mule-plugin</classifier>
    </dependency>
  </dependencies>
</project>
----

{NOTE} _Because you use a monorepo, the {POM} can safely load the {PPOM} through its relative path in the parent directory._

{NOTE} _You define a dependency on the {CIPAPI} {APISpec}, which is not managed in the {PPOM}, and must therefore include the {MVNVersionElem} element._

{NOTE} _You define dependencies on {AKit} and {HTTPConn}, which are managed in the {PPOM}, and therefore do not require a {MVNVersionElem} element._

{NOTE} _Due to a current limitation in Mule {MVN} tooling, the dependency on the {HTTPConn} must be defined before the dependency on {AKit}._

{NOTE} _You define the execution of the {MMP} without repeating its configuration, because that is inherited from the {PPOM}._
--
+
. *{RUNINV}* Run the {MApp} from {Studio} and invoke the {API} as before; this should return an HTTP 200 OK response.

[[wt2-2-introduce-bom]]
==== Centralize {MVN} dependency and plugin versions in a {BOM}

The {PPOM} introduced in the previous section combines plugin configuration and the definition ("management") of versions of dependencies and plugins. Configuration and version management typically change on a different timescale: once a project has matured, it is more common to update the version of dependencies or plugins, than it is to change the configuration of plugins.

{InThisWTSecYou} separate version management of {MVN} dependencies and {MVN} plugins into its own special kind of {PPOM} — a {BOM}. Instead of building the {BOM} by hand, however, you use {AA}'s standard {BOM} for {MApps}. This is a {BOM} that manages the complete set of {MVN} dependencies and plugins used by {AA} and in all {WTs} of this course.

A {BOM} — short for Bill Of Materials — is, by convention, a kind of {PPOM} that only defines the versions of {MVN} dependencies, including the versions of {MVN} plugin dependencies.
A generic {PPOM}, on the other hand, has a broader purpose than a {BOM} and may also define configurations for {MVN} plugins and other elements of the build that go beyond simply managing versions. If a {BOM} is used together with a generic {PPOM}, like here, then it is good practice that the {PPOM} contains no version management at all, as this is done exclusively in the {BOM}.

[start=20]
. *Identify dependency versions:* In *{PPOMXml}* and identify all *{MVNVersionElem}* elements of dependencies, either of a {MVN} plugin or normal {MVN} dependency.
. *Copy {AA}'s {BOM}:* Copy {AA}'s complete *{BOMXml}* into an new *{BOMDir}* directory within the {Studio} workspace directory; from now on you will be using this {BOM}, which already manages all relevant dependencies:
+
--
[source,bash,subs="attributes+"]
----
cd ${WSEnvVar}
mkdir {BOMDir}
cp {SolDir122}/{BOMXml} {BOMDir}
----

{NOTE} _This is {AA}'s {BOM}, which manages all dependencies defined in your current {PPOM} — and many more._

{NOTE} _Both {PPOMXml} and {BOMXml} now reside in the parent directory of the {CIPAPII} project._
--
+
. *Study {BOM}:* Browse the content of the {BOMXml}, identifying the overlap with {PPOMXml} in terms of the definition of {MVN} properties, {MVNDepMgmtElem}, {MVNPlugMgmtElem}, and the repositories where these dependencies can be retrieved from.
+
--
{NOTE} _Defining {MVN} properties for all versions makes changing these versions even easier._

{NOTE} _{BOMs} by convention never impose any actual dependencies or plugin executions on their child projects — they just tie down dependency versions._
--
+
. *Update groupId:* Update {BOMXml} adapting the {MVNCoords} to match the groupId of your {APOrg} ID:
+
--
.{BOMXml}
[source,subs="attributes+"]
----
<project>
  <groupId>your-AP-organization-id</groupId>
  <artifactId>solutions-bom</artifactId>
  <version>1.0.0-SNAPSHOT</version>
  ...
</project>
----

{NOTE} _This {POM} uses the {APOrg} ID for the groupId, as this is a prerequisite for publishing to {Exchange}, which you will do later._
--
+
. *Turn {PPOM} into {CPOM} of {BOM}:* Change *{PPOMXml}* into a {CPOM} of {BOMXml} by defining *{BOMXml}* as its {PPOM} and removing all configuration now inherited from the {BOM}: {MVNDepMgmtElem}, {MVNReposElem}, and all {MVNVersionElem} elements of {MVN} plugins:
+
--
.{PPOMXml}
[source]
----
<project>
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>your-AP-organization-id</groupId>
    <artifactId>solutions-bom</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <relativePath>../bom/pom.xml</relativePath>
  </parent>
  <artifactId>solutions-parent-pom</artifactId>
  <groupId>your-AP-organization-id</groupId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <name>solutions-parent-pom</name>

  <build>
    <resources>...</resources>
    <testResources>...</testResources>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-resources-plugin</artifactId>
          <configuration>...</configuration>
        </plugin>
        <plugin>
          <groupId>org.mule.tools.maven</groupId>
          <artifactId>mule-maven-plugin</artifactId>
          <extensions>true</extensions>
          <configuration />
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>
----

{NOTE} _This {POM} is both a {PPOM} of {CIPAPII}'s {POM} as well as a {CPOM} of the {BOM}. It has no {MVNVersionElem} elements for plugins or dependencies because it inherits all those from the {BOM}._

{NOTE} _This {POM} uses the {APOrg} ID for the groupId, as this is a prerequisite for publishing to {Exchange}, which you will do later._

{NOTE} _The configuration of the {MMP} will soon get much more involved, making it more obvious why it is beneficial to encapsulate it into this {PPOM} rather than repeating it in all {CPOMs}._
--
+
. *{RUNINV}* Run the {MApp} from {Studio} and invoke the {API} as before; this should return an HTTP 200 OK response.

:sectnums:
//....................................................................................................................

//....................................................................................................................
<<<
:sectnums!:
[[wt-begin-123]]
=== {WT-c} {mct}-{counter:wtct}: Build and deploy Mule applications with Maven


The {CIPAPII} {MApp} you have developed so far relies on {Studio} populating the local {MVN} repository with artifacts (libraries) that are needed for the {MVN} build of {MApps}. For many real-world scenarios, additional {MVN} configuration is needed to perform {MVN} builds reproducibly and independently of {Studio}. Another common feature of real-world {MVN} builds of {MApps} is automated deployment to {CH2}.

{InThisWTYou} address both of these common requirements for your {MVN} build of {CIPAPII} and future {MApps}.

{YouWill}

* <<Install a {MVN} {SettingsXml}>>.
* <<Deploy to {CH} using the {MMP}>>.

==== Solution file
{YouSeeSol} {SolDir123}.

==== Starting file
{YouMightNeedStarter} {SolDir122}.

==== Install a {MVN} {SettingsXml}

{InThisWTSecYou} create a global {MVN} {SettingsXml} that allows a {MVN} build outside of {Studio} to retrieve artifacts — such as the {CIPAPI} {APISpec} — from your {APOrg}'s {Exchange}.

. *{BUILD}* In a {CLI}, navigate to the *base directory* of {CIPAPII} and run a {MVN} build of this {MApp}; this should succeed:
+
--
[source,bash,subs="attributes+"]
----
cd ${WSEnvVar}/{CIPAPII}
mvn clean verify
----

{NOTE} _If {Studio} had not populated the local {MVN} repository with all required artifacts, this build would have failed (unless you already have a suitable {SettingsXml} installed). You will prove this by deleting the local {MVN} repository at {MVNRepo} and re-running the build._
--
+
. *Discover remote {MVN} repos:* Inspect *{BOMXml}* and note the {MVN} repositories which {Studio} added when creating the {MApp} project; one of these repositories is {Exchange}, the other a {MS} public repository — the former requires authentication.
. *Delete local {MVN} repo:* From your local {MVN} repository, delete some artifacts that were put there by {Studio}:
+
--
[source,bash,subs="attributes+"]
----
rm -rf {MVNRepo}/*-*-*-*-*
----

{NOTE} _This command is likely to delete all artifacts downloaded from any {Exchange}._

{NOTE} _You refrain from deleting the entire local {MVN} repository, because re-populating it just by downloading {MVN} dependencies would take too long. The above partial delete suffices to prove the point._
--
+
. *{BUILD}* Re-run the {MVN} build from a {CLI}; this should now fail due to unresolvable dependencies.
. *Create {Exchange} Viewer {CAPP}:* In *{AAM}*, create a new *{CAPP}* that acts on its *own behalf (client credentials)*, for reading assets from {Exchange}, adding the *Exchange Viewer* scope and retrieve its {CIDS}.
. *Create {SettingsXml}:* In a text editor, create *{SettingsXml}* in *{MVNDir}* with credentials for reading from your {APOrg}'s {Exchange} as a {MVN} repository:
+
--
.{SettingsXml}
[source]
----
<settings>
  <servers>
    <server>
      <id>anypoint-exchange-v3</id>
      <username>~~~Client~~~</username>
      <password>your-capp-viewer-cid~?~your-capp-viewer-secret</password>
    </server>
  </servers>
</settings>
----

{NOTE} _You can also use {AP} credentials for an account of your {APOrg} with which you were able to search your {Exchange} — such as the trial account credentials created previously. However, it is best practice to use a {CAPP} for security._

{NOTE} _To use {CAPP} authentication, provide basic authentication and define the username as \~~~Client\~~~ and the password as clientID\~?~clientSecret. Replace clientID with the client ID. Replace clientSecret with the client secret._

{NOTE} _{MVN} allows passwords in {SettingsXml} to be encrypted, but this is not done here for simplicity's sake._

{NOTE} _The server entry in {SettingsXml} and the repository entry in the {BOM} are matched by the common ID._

{NOTE} _All {Exchange} {MVN} repositories use the same URL (and, by default, also the same ID); their content is determined by the credentials used._

{NOTE} _Because the above {SettingsXml} entry uses the default {Exchange} repository ID, it is dangerous: whenever this user-wide {MVN} configuration is in use, all default {Exchange} repository definitions (which use the default repository ID) in any {POM}, regardless of what project the {POM} belongs to, will access your {APOrg}'s {Exchange}. For this reason, it is typically recommended to change repository IDs to be unique to the actual {Exchange} being accessed, for example by appending the organization ID to the repository ID. You will do this in a later {WT}._
--
+
. *{BUILD}* In a {CLI}, re-run a {MVN} build of {CIPAPII} as before; this should now succeed.

[[wt2-3-deploy-to-ch]]
==== Deploy to {CH} using the {MMP}

{InThisWTSecYou} extend the existing {MVN} build configuration to perform automated deployments to {CH2}. To do so you add the relevant configuration for the {MMP} to the {PPOM} and create a {CAPP} for authentication. You then deploy {CIPAPII} to {Exchange} and the {CH2} {PRODEnv} environment from the {MVN} {CLI}, passing the {CIDS} required by the uplink to the {AP} control plane as command-line arguments to {MVN}.

[start=8]
. *Configure {CH2} deployment:* Add to the *{PPOM}* the *{MMP}* configuration for a simple deployment to a {CHSS}, utilising {OStore} v2:
+
--
.{PPOMXml}
[source]
----
include::{LocalSolDir123}/{PPOMXml}[tags={MMPConfigTag}]
----

{NOTE} _This configuration applies by default to all {MVN} child projects._

{NOTE} _This configuration uses a {CAPP} {CIDS} for authentication, which you will create shortly._

{NOTE} _Instead of using {CAPPS}, you can use a {MMPServerElem} that refers to an entry in {SettingsXml} to authenticate using an {AP} account. However, this does not support using {CAPP} {CIDS} as {MVN} credentials._

{NOTE} _You explicitly deploy to the master (root) {APOrg}, rather than a business group therein, by leaving {MMPBGElem} empty._

{NOTE} _The {MR} version must be specified via the simplified, semantic version ({MRSemVersion}) rather than the full version ({MRVersion}). Of course, this only applies in the rare cases where there is a difference between these two version strings._

{NOTE} _{CIDS} are directly passed to the {MApp}, but need to be set on the {MVN} {CLI}._

{NOTE} _The {PRODEnv} environment is hard-coded for the moment, and you will correct this in a later {WT}._

{NOTE} _{AP} trial accounts can only deploy to 1 worker in {CHRegionUSE2}, so these values are hard-coded._

{NOTE} _To use as few vCores as possible, you hard-code deployment to 0.1._
--
+
. *Study and update {BOM} distributionManagement:* Notice and update the {MVN} property: *student.deployment.ap.orgid*, replacing the entire value with your {APOrg} used to configure the *{MVNDistMgmtElem}*:
+
--
.{BOMXml}
[source]
----
...
<properties>
  ...
  <student.deployment.ap.orgid>your-AP-organization-id</student.deployment.ap.orgid>
</properties>
...
<repositories>
  <repository>
    <id>anypoint-exchange-v3-student-deployment</id>
    <name>Anypoint Exchange</name>
    <url>https://maven.anypoint.mulesoft.com/api/v3/maven</url>
  </repository>
  ...
</repositories>

<distributionManagement>
  <repository>
    <id>anypoint-exchange-v3-student-deployment</id>
    <name>AnyAirline Anypoint Exchange</name>
    <url>https://maven.anypoint.mulesoft.com/api/v3/organizations/${student.deployment.ap.orgid}/maven</url>
    <layout>default</layout>
  </repository>
</distributionManagement>
...
----
{NOTE} _Replace the entire contents of the property with your value and not any other properties the value currently references._
--
+
. *Create {Exchange} Contributor {CAPP}:* In *{AAM}*, create a new *{CAPP}* that acts on its *own behalf (client credentials)*, for writing assets to {Exchange}, adding the *Exchange Contributor* scope and retrieve its {CIDS}.
. *Update {SettingsXml}:* Change in {SettingsXml} the credentials of the matching *server* entry for the repository defined in the distributionManagement section of the {BOMXml} to use the {CAPP} credentials created previously for writing to that repository:
+
--
.{SettingsXml}
[source]
----
<server>
  <id>anypoint-exchange-v3-student-deployment</id>
  <username>~~~Client~~~</username>
  <password>your-capp-contributor-cid~?~your-capp-contributor-secret</password>
</server>
----

{NOTE} _Only the {Exchange} {CAPP} is configured the {MVN} {SettingsXml}, not the {CH} {CAPP} as the {MMP} does not support using {CAPP} {CIDS} as {MVN} credentials and must be configured directly in the plugin configuration._

{NOTE} _You can also use {AP} credentials for an account of your {APOrg} with which you were able to search your {Exchange} — such as the trial account credentials created previously. However, it is best practice to use a {CAPP} for security._

{NOTE} _To use {CAPP} authentication, provide basic authentication and define the username as \~~~Client\~~~ and the password as clientID\~?~clientSecret. Replace clientID with the client ID. Replace clientSecret with the client secret._
--
+
. *Ensure {PPOMs} use release versions:* Ensure the *{BOM}*, *{PPOM}* and {CIPAPII} artifact version is a release version and not a SNAPSHOT:
+
--
.{BOMXml}
[source]
----
...
<version>1.0.0</version>
...
----

.{PPOMXml}
[source]
----
...
<parent>
  <!-- students: replace with your AP org ID -->
  <groupId>your-AP-organization-id</groupId>
  <artifactId>solutions-bom</artifactId>
  <version>1.0.0</version>
  <relativePath>../bom/pom.xml</relativePath>
</parent>
...
<version>1.0.0</version>
...
----

.{POMXml} of {CIPAPII}
[source]
----
...
<parent>
  <!-- students: replace with your AP org ID -->
  <groupId>your-AP-organization-id</groupId>
  <artifactId>solutions-parent-pom</artifactId>
  <version>1.0.0</version>
  <relativePath>../parent-pom/pom.xml</relativePath>
</parent>
...
<version>1.0.0</version>
...
----
{NOTE} _Although {Exchange} supports SNAPSHOT versions, not all {AP} components support them such as RTF. Therefore, for consistency you will use release versions for all dependencies and release and increase version numbers before every {CH2} deployment._
--
+
. *Deploy application to {Exchange}:* Deploy {CIPAPII} to your remote {Exchange} repository:
+
--
[source,bash,subs="attributes+"]
----
cd ${WSEnvVar}/{CIPAPII}
mvn clean deploy
----
--
+
__
{NOTE} _With {CH1} and Standalone {MRs}, applications are deployed to a {MR} directly. {CH2} and {RTF} are container based platforms and require the application binary to be deployed to {Exchange} first as a persistent store so the application can be retrieved and used to scale containers or recover failed containers._
__
+
. *Create {CH} Deployment {CAPP}:* In *{AAM}*, create a new *{CAPP}* that acts on its *own behalf (client credentials)*, for deployment to CH, adding the *Cloudhub Organization Admin*, *Create Applications*, *Delete Applications*, *Read Applications*, *View Environment*, *View Organization* and *Design Center Developer* scopes and applying to all environments and retrieve its {CIDS}.

. *{BUILDDEPLOY}* In a {CLI}, deploy to {CH2} using the {MMP}, supplying the same {CIDS} of your {APOrg} as previously and the {CIDS} of your {CH} Deployment {CAPP}; this should result in a successful build:
+
--
[source,bash]
----
mvn -DmuleDeploy deploy -Dap.client_id=<insert-your-client-id> -Dap.client_secret=<insert-your-client-secret>
  -Dap.ca.client_id=<insert-your-ca-client-id> -Dap.ca.client_secret=<insert-your-ca-client-secret>
----

{NOTE} _The supplied system properties match the {MMP} configuration._

{NOTE} _For the {MMP} to execute a deployment, the {MVN} lifecycle phase and the shown system property must both be specified._

{NOTE} _This triggers a deploy or re-deploy, depending on whether a {CH} deployment with the given name already exists or not._
--
+
. *Locate {FQDN}:* In *{ARM}*, verify the successful deployment of {CIPAPII} to the *{PRODEnv}* environment and copy the {API}'s endpoint URL with the additional six-character uniq-id and shard.
. *{INV}* Invoke the {API} using this endpoint URL; this should return an HTTP 200 OK response:
+
--
include::{LocalCurlCheckinSmithStudent}[]

{NOTE} _Ensure to replace the placeholders for the six-character unique id and shard for your individual application._
--
+
. *{CHECKLOG}* In *{ARM}*, inspect the log entries as before.
. *Check {APIInst}:* In *{AManager}*, the status of the corresponding {APIInst} should (still) be active/green.

:sectnums:
//....................................................................................................................

//....................................................................................................................
<<<
:sectnums!:
[[wt-begin-124]]
=== {WT-c} {mct}-{counter:wtct}: Configure secure environment properties

The current implementation of {CIPAPII} supports configuration for and deployment to just one environment — and where necessary you have chosen this to be the {PRODEnv} environment. {InThisWTYou} extend {CIPAPII} and its {MVN} build to support additional environments. Furthermore, you will protect sensitive property values in {ARM} by stopping the cleartext display for these values.

{YouWill}

* <<Configure a {MApp} for different runtime environments>>.
* <<Encrypt sensitive {Mapp} configuration properties>>.
* <<Protect sensitive {Mapp} configuration properties in {ARM}>>.
* <<Deploy the same {MApp} to different {CH} environments>>.

==== Solution file
{YouSeeSol} {SolDir124}.

==== Starting file
{YouMightNeedStarter} {SolDir123}.

==== Configure a {MApp} for different runtime environments

{InThisWTSecYou} introduce environment-specific configuration to {CIPAPII}. You extract all environment-specific configuration properties, including the filenames and passwords of keystores, into their respective environment-specific properties file. You then create {APIInsts} for {CIPAPI} in the {DEVEnv} and {TESTEnv} {AP} environments and complete the {AutoDisc} configuration of {CIPAPII} for these environments.

. *Add {EnvProp} property:* In {Studio}, near the top of *{GlobalXml}*, define a property {EnvProp} that will at runtime always hold the identifier of the environment in which the {MApp} currently executes, and default this value to {DEVEnv}:
+
--
.{GlobalXml} of {CIPAPII}
[source]
----
<global-property name="env" value="dev" />
----

{NOTE} _Every {MR} in which {CIPAPII} executes has to identify the environment to which it belongs by setting {EnvProp}, otherwise it will be taken to be in the {DEVEnv} environment._
--
+
. *Read env-dependent props file:* Just below, read from a properties file whose name contains the current environment, such as *{DevPropYaml}*; these files will contain environment-dependent properties:
+
--
.{GlobalXml} of {CIPAPII}
[source]
----
<configuration-properties file="${env}-properties.yaml" />
<configuration-properties file="properties.yaml" />
----

{NOTE} _With this ordering, environment-dependent properties are defined before, and take precedence over, environment-independent properties. Also, the latter can refer to the former, but not the other way round._
--
+
. *Create {PRODEnv}-dependent props file:* Create prod-dependent configuration file *{ProdPropYaml}* in *{SrcMR}* to add explicit support for the {PRODEnv} environment and move all environment-dependent properties from *{PropYaml}* to *{ProdPropYaml}*, because so far you have only made use of the {PRODEnv} environment:
+
--
.{ProdPropYaml} of {CIPAPII}
[source,yaml]
----
api:
  id: "15678353"

tls.keystore:
  type:        "pkcs12"
  path:        "check-in-papi.p12"
  alias:       "server"
  password:    "mule12345"
  keyPassword: "mule12345"
----

{NOTE} _You hereby assume — very realistically — that different environments use independent certificates and keystores for exposing HTTPS endpoints._
--
+
. *Create keystores for {DEVEnv} and {TESTEnv}:* Copy *{CIPAPIKSProd}* to *{CIPAPIKSDev}* and *{CIPAPIKSTest}*; this simulates the creation of independent certificates and keystores for all three environments.
+
--
{NOTE} _This "simulation" leads to keystores and passwords (for keystores and keys) that are the same in all environments, which is of course not generally recommended._

{NOTE} _If time permits actually create independent keypairs and keystores as <<create-cert-and-keystore-for-exposing-https,before>>._

{NOTE} _The naming convention for certificates, as applied here, is the same as for {CH} hostnames: the {DEVEnv} and {TESTEnv} environments use the respective environment suffix {DNSSuffixDev} and {DNSSuffixTest}, respectively, while the {PRODEnv} environment does not use a suffix. This is just a convention._
--
+
. *Move keystores:* Move all keystores to a new directory *{SrcMRCerts}* to separate properties files from keystores.
. *Update path property:* Correct the keystore path in *{ProdPropYaml}*:
+
--
.{ProdPropYaml} of {CIPAPII}
[source,yaml]
----
tls.keystore:
  path:        "certs/check-in-papi.p12"
----
--
+
. *Create {DEVEnv}-dependent props file:* Copy *{ProdPropYaml}* to *{DevPropYaml}* and change the latter to add explicit support for the {DEVEnv} environment:
+
--
.{DevPropYaml} of {CIPAPII}
[source,yaml]
----
api:
  id: ""

tls.keystore:
  type:        "pkcs12"
  path:        "certs/check-in-papi-dev.p12"
  alias:       "server"
  password:    "mule12345"
  keyPassword: "mule12345"
----

{NOTE} _You don't know the {APIID} in {DEVEnv} yet._

{NOTE} _The passwords are the same in all environments because you just copied the keystores._
--
+
. *Create {TESTEnv}-dependent props file:* Copy *{ProdPropYaml}* to *{TestPropYaml}* and change the latter to add explicit support for the {TESTEnv} environment:
+
--
.{TestPropYaml} of {CIPAPII}
[source,yaml]
----
api:
  id: ""

tls.keystore:
  type:        "pkcs12"
  path:        "certs/check-in-papi-test.p12"
  alias:       "server"
  password:    "mule12345"
  keyPassword: "mule12345"
----

{NOTE} _You don't know the {APIID} in {TESTEnv} yet._

{NOTE} _The passwords are the same in all environments because you just copied the keystores._
--
+
. *Create {APIInst} in {TESTEnv}:* In *{AManager}*, go to the *{TESTEnv}* environment and create a new {APIInst} for {CIPAPI} by promoting the existing instance from the *{PRODEnv}* environment and then fixing the implementation and consumer URLs by appending *{DNSSuffixTest}* to the hostname, such as {CIPAPIStudHostTest}; remember the {APIID} of this {APIInst}.
+
--
{NOTE} _The {DNSSuffixTest} hostname suffix is the same as for the respective keystore above, and its necessity will become clear shortly._

{NOTE} _Promotion is typically done from a lower environment ({TESTEnv}) to a higher environment ({PRODEnv}) not the other way round like here. You do "reverse promotion" here because you started in {PRODEnv}._
--
+
. *Create {APIInst} in {DEVEnv}:* In *{AManager}*, go to the *{DEVEnv}* environment and create a new {APIInst} for {CIPAPI} by promoting the existing instance from the *{TESTEnv}* environment and then fixing the implementation and consumer URLs by appending *{DNSSuffixDev}* to the hostname, such as {CIPAPIStudHostDev}; remember the {APIID} of this {APIInst}.
+
--
{NOTE} _The {DNSSuffixDev} hostname suffix is the same as for the respective keystore above, and its necessity will become clear shortly._

{NOTE} _Promotion is typically done from a lower environment ({DEVEnv}) to a higher environment ({TESTEnv}) not the other way round like here._
--
+
. *Apply {AAPolicies} in {DEVEnv} and {TESTEnv}:* Create *{AAPolicies}* in the {DEVEnv} and {TESTEnv} environments, mirroring those in the {PRODEnv} environment.
. *Update {APIIDs}:* Update *{DevPropYaml}* and *{TestPropYaml}* with the {APIIDs} for the newly created {APIInsts} in the {DEVEnv} and {TESTEnv} environments, respectively.
. *{RUNINV}* Run the {MApp} from {Studio} and invoke the {API} as before; this should return an HTTP 200 OK response:
+
--
include::{LocalCurlCheckinSmithLocal}[]

{NOTE} _This uses the default {DEVEnv} environment configuration._
--
. *Switch to {TESTEnv} config:* In {Studio}, change the *run configuration* by adding the following *VM argument* for *{EnvProp}*, to explicitly load the configuration for the {TESTEnv} environment, then re-start the {CIPAPII}:
+
[source,bash]
----
-M-Denv=test
----
+
. *Check {APIInst}:* In *{AManager}*, the status of the corresponding {APIInst} in the {TESTEnv} environment, should now be active/green; this may take a few minutes; watch-out for the "unblocked" log entry in {ARM}, as before.
. *Switch back to {DEVEnv}:* Change to {Studio} run configuration back to the {DEVEnv} environment either by deleting the *{EnvProp}* VM argument or by changing its value to {DEVEnv}:
+
[source,bash]
----
-M-Denv=dev
----

[[wt2-4-encrypt-sensitive-props]]
==== Encrypt sensitive {Mapp} configuration properties

{InThisWTSecYou} add the {SecPropsModule} to the {MVN} build and {CIPAPII} and use it to protect the values of sensitive properties, such as passwords. To do so you introduce environment-specific secure properties files, which contain values encrypted with the {SecPropsTool}, and which are read and decrypted by the {SecPropsModule}. You start {CIPAPII} in {Studio} with the encryption key required by the {SecPropsModule} supplied as a Java system property.

[start=17]
. *Add {SecPropsModule}:* In {Studio}, install from {Exchange} the {SecPropsModule}; this adds support for encrypted (secure) values in properties files.
. *Locate {MVN} dependency:* Locate in *{POMXml}* the {MVN} dependency to {SecPropsModule} added by {Studio}.
. *Use managed dependency:* Locate in *{BOMXml}* the existing entry in {MVNDepMgmtElem} that defines the (default) version of {SecPropsModule}, and remove the corresponding {MVNVersionElem} from {POMXml}.
+
--
.{POMXml} of {CIPAPII}
[source]
----
<dependencies>
  ...
  <dependency>
    <groupId>com.mulesoft.modules</groupId>
    <artifactId>mule-secure-configuration-property-module</artifactId>
    <classifier>mule-plugin</classifier>
  </dependency>
</dependencies>
----

{NOTE} _You do not have to increment the version number of {POMXml} itself, despite changing this file, because it uses a snapshot version._
--
+
. *Download {SecPropsTool}:* Download the {SecPropsTool} from *{SecPropsToolUrl}* to a filesystem location of your choice, such as {TmpDir}:
+
[source,bash,subs="attributes+"]
----
curl {SecPropsToolUrl} -o {SecPropsToolPath}
----
+
. *Move sensitive props:* Extract all sensitive properties from *{DevPropYaml}* to a new file *{DevSecPropYaml}*:
+
.{DevSecPropYaml} of {CIPAPII}
[source,yaml]
----
tls.keystore:
  password:    "mule12345"
  keyPassword: "mule12345"
----
+
. *Encrypt secure props file for {DEVEnv}:* In a {CLI}, navigate to the *base directory* of {CIPAPII} and use *{SecPropsTool}* to encrypt the values in *{DevSecPropYaml}*, using Blowfish and CBC for encryption:
+
--
[source,bash,subs="attributes+"]
----
cd ${WSEnvVar}/{CIPAPII}/{SrcMR}
{SecPropsToolExec} file encrypt Blowfish CBC {EncKeyVal} {DevSecPropYaml} tmp.yaml
mv tmp.yaml {DevSecPropYaml}
----

{NOTE} _The {SecPropsTool} does not allow you to change a properties file in place._
--
+
. *Study encrypted values:* Inspect the encrypted values in *{DevSecPropYaml}*, to understand their syntax:
+
.{DevSecPropYaml} of {CIPAPII}
[source,yaml]
----
tls.keystore:
  password: "![c72bREVng+8ns4IMHA/S2Q==]"
  keyPassword: "![c72bREVng+8ns4IMHA/S2Q==]"
----
+
. *Create secure props files for {TESTEnv} and {PRODEnv}:* Copy {DevSecPropYaml} to *{TestSecPropYaml}* and *{ProdSecPropYaml}*:
+
--
[source,bash,subs="attributes+"]
----
cp {DevSecPropYaml} {TestSecPropYaml}
----

[source,bash,subs="attributes+"]
----
cp {DevSecPropYaml} {ProdSecPropYaml}
----

{NOTE} _You use the same encryption key ({EncKeyVal}) for all environments: this is purely for simpliciy's sake and not generally recommended._

{NOTE} _Because the encryption details and sensitive properties are the same in all environments, the encrypted secure properties files are also identical between environments._
--
+
. *Read secure props file:* In {Studio}, in {GlobalXml}, add a global element to read the encrypted environment-dependent properties file for the current environment, using a new property *{EncKey}* for the encryption key:
+
--
.{GlobalXml} of {CIPAPII}
[source]
----
<secure-properties:config file="${env}-secure-properties.yaml"
  key="${encrypt.key}" name="secureEnvPropsConfig">
  <secure-properties:encrypt algorithm="Blowfish" />
</secure-properties:config>
----

{NOTE} _You must specify Blowfish because it is not the default algorithm, whereas CBC is the default and does not need to be mentioned._

{NOTE} _Secure and normal properties cannot reference each other, so the order relative to each other does not matter._
--
+
. *Reference secure props:* *Prefix* all references to secure properties with *{SecPropsPrefix}* as follows:
+
.{GlobalXml} of {CIPAPII}
[source]
----
<tls:context name="apiTLSContext">
  <tls:key-store type="${tls.keystore.type}" path="${tls.keystore.path}"
    password="${secure::tls.keystore.password}"
    keyPassword="${secure::tls.keystore.keyPassword}"
    alias="${tls.keystore.alias}" />
</tls:context>
----
+
. *Update run config:* In {Studio}, change the *run configuration* of {CIPAPII} by setting the *VM arguments* for *{EncKey}*:
+
--
include::{LocalSetMulePropsEncKey}[]

{NOTE} _Because {EncKey} is not — and should not be — defaulted, the {MApp} will not start unless this property is set by the {MR} in every environment — includig {CH}, which will be addressed shortly._

{NOTE} _Due to a current limitation in {Studio}, DataSense metadata support fails due to the {Studio} tooling instance not being able to locate the {EncKey} that's only passed at runtime. During development, there are temporary workarounds such as setting a temporary global {EnvProp} to provide the runtime property to the {Studio} tooling instance, but caution should be exercised to not deploy this change or commit to any SCM._
--
+
. *{RUN}* Run {CIPAPII} in {Studio} and verify that it starts up correctly.

==== Protect sensitive {Mapp} configuration properties in {ARM}
//CH2TODO
{InThisWTSecYou} protect sensitive properties that must be set as Java system properties, such as {EncKey} and the {AP} {CIDS}, in the {ARM} web UI and by extending the {MVN} build configuration in the {PPOM} to automatically protect these value upon deployment.

[start=29]
. *Review unprotected properties:* In the {ARM} dashboard, navigate to the Properties tab of {CIPAPII}. Note that all properties are visible in plain text.
. *Protect sensitive properties:* Add the *{EncKey}* property, click *Protect* and apply the changes.
. *Confirm protected properties:* On the Properties tab, confirm the value for property that you just protected is now no longer visible.
+
--
{NOTE} _These protected application values are encrypted and stored in the Anypoint Security secrets manager, which, in turn, is encrypted per user organization._

{NOTE} _Properties set only in properties files, including secure/encrypted properties, do not have to be included here, as they are not visible in {ARM}._
--
. *Update {CH2} deployment config:* Change the {MMP} configuration to protect the sensitive properties: *{EncKey}* and the {AP} *{CIDS}*, moving them to their own *secureProperties* configuration element:
//CH2TODO
+
--
.{PPOMXml}
[source]
----

<configuration>
  <cloudhub2Deployment>
    ...
    <properties>
    ...
    </properties>
    <secureProperties>
      <encrypt.key>${encrypt.key}</encrypt.key>
      <anypoint.platform.client_id>${ap.client_id}</anypoint.platform.client_id>
      <anypoint.platform.client_secret>${ap.client_secret}</anypoint.platform.client_secret>
    </secureProperties>
    ...
  </cloudhub2Deployment>
</configuration>
----
{NOTE} _You will validate these values are protected in {ARM} when you deploy via the {MMP} in the next section._

--

==== Deploy the same {MApp} to different {CH} environments

{InThisWTSecYou} extend the {MVN} build configuration in the {PPOM} to perform automated {CH} deployments via {MMP} to different environments. You give deployments to the {CH} {DEVEnv} and {TESTEnv} environments a hostname suffix to denote the respective environment, and thereby make the hostnames unique. You also pass the environment name and encryption key as Java system properties to the {MApp}, so that it can start-up in {CH} with the appropriate environment-specific configuration. You then deploy {CIPAPII} to all environments using the {MVN} {CLI}.

[start=33]
. *Add env config to {PPOM}:* Add *properties* to *{PPOMXml}* that capture the environment and formalize the variations of {CH} deployment/application names between different environments; this includes the same hostname prefix as before plus a new hostname suffix:
+
--
.{PPOMXml}
[source]
----
include::{LocalSolDir124}/{PPOMXml}[tags={MVNPropsTag}]
----

{NOTE} _The same {MApp} deployed to different {CH} environments in the same region must be given distinct names to avoid duplicate {FQDN}s._

{NOTE} _In {PRODEnv} you will continue using no hostname suffix, as is common usage, by setting the suffix property to the empty string._

{NOTE} _You define two separate {MVN} properties related to environments: Firstly, a {MVN} property for the name by which {MApps} identify the current environment, for the purpose of selecting environment-specific configuration; this will be passed to the {MApp} through the {EnvProp} property. Secondly, a {MVN} property for the name of the {AP} (and therefore {CH}) environment to which the {MApp} is to be deployed. You also make explicit your chosen convention that these two properties hold the same value, while keeping the option of departing from this convention if necessary, by maintaining two separate {MVN} properties._
--
+
. *Update {CH2} deployment config:* Change the {MMP} configuration to make use of the name and environment *properties*:
+
--
.{PPOMXml}
[source]
----

<configuration>
  <cloudhub2Deployment>
    ...
    <environment>${ap.environment}</environment>
    ...
    <applicationName>${deployment.name}</applicationName>
    ...
    <properties>
      ...
      <env>${deployment.env}</env>
    </properties>
  </cloudhub2Deployment>
</configuration>
----

{NOTE} _You instruct the {MMP} to deploy to the {CH} environment identified by the respective {MVN} property, set previously._

{NOTE} _You set the {EnvProp} property of the {MApp} from the {MVN} property that identifies the environment. By default, as set above, this is the name of the {CH} environment._
--
+
. *Bump {CIPAPII} {MVN} artifact version:* In *{POMXml}*, update the version to a release version:
+
--
.{POMXml} of {CIPAPII} 
[source]
----
...
<version>1.0.1</version>
...
----
--
+
. *Deploy application to {Exchange}:* Deploy {CIPAPII} to your remote {Exchange} repository, this time passing in the required encryption key:
+
--
include::{DeployCIPAPIIExchange}[]
--
+
. *{BUILDDEPLOY}* In a {CLI}, deploy {CIPAPII} to all supported {CH} environments, supplying the same {CIDS} of your {APOrg} as before, and only deploying to {Exchange} once, reusing the already packaged application from {Exchange} for subsequent deployments:
+
--
[source,bash,subs="attributes+"]
----
mvn -DmuleDeploy deploy -Dap.client_id=<insert-your-client-id> -Dap.client_secret=<insert-your-client-secret> -Dap.ca.client_id=<insert-your-ca-client-id> -Dap.ca.client_secret=<insert-your-ca-client-secret>
  -Dencrypt.key={EncKeyVal} -Ddeployment.env=dev
----

[source,bash,subs="attributes+"]
----
mvn -DmuleDeploy deploy -Dap.client_id=<insert-your-client-id> -Dap.client_secret=<insert-your-client-secret> -Dap.ca.client_id=<insert-your-ca-client-id> -Dap.ca.client_secret=<insert-your-ca-client-secret>
  -Dencrypt.key={EncKeyVal} -Ddeployment.env=test
----

[source,bash,subs="attributes+"]
----
mvn -DmuleDeploy deploy -Dap.client_id=<insert-your-client-id> -Dap.client_secret=<insert-your-client-secret> -Dap.ca.client_id=<insert-your-ca-client-id> -Dap.ca.client_secret=<insert-your-ca-client-secret>
  -Dencrypt.key={EncKeyVal} -Ddeployment.env=prod -Ddeployment.suffix=
----
{NOTE} _As per the chosen convention, the deployment/hostname suffix for {PRODEnv} is empty._

{NOTE} _If you were to use environment-level rather than organization-level {CIDS}, then the values for {CIDS} in each of these statements would be different._
--
+
. *{WAIT}* In *{ARM}* and *{AManager}*, follow the deployment process and verify its success.
. *{INV}* Invoke the {CIPAPI} endpoints in all environments to verify the successful deployments:
+
--

include::{LocalCurlCheckinSmithStudent}[]

{NOTE} _The hostnames will be different for you._
{NOTE} _Append the -dev or -test suffix to the application name in the URL for the corresponding environment._
--

. *Confirm protected properties:* On the Properties tab, confirm the values for each property that you protected earlier are now no longer visible.
and the {AP} {CIDS}.
. *Set consumer and implementation endpoints:* in {AManager}, update the implementation URL and consumer endpoint to match your generated {FQDN}.
+
--
{NOTE} _These endpoints are optional and are used for informational purposes to let clients know how to interact with your API, including surfacing these endpoints in {Exchange}._
--

:sectnums:
//....................................................................................................................

//....................................................................................................................
