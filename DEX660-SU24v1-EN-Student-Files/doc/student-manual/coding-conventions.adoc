// Copyright (C) MuleSoft, Inc. All rights reserved. http://www.mulesoft.com
//
// The software in this package is published under the terms of the
// Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License,
// a copy of which has been included with this distribution in the LICENSE.txt file.
[[module-coding-conventions]]
[appendix]
== Coding conventions

=== General

* *Importing {APISpecs} into a {Studio} project:* Don’t import from {ADesigner} but import a well-defined version of the {APISpec} ({RAMLDef} or {OASDef}) from {Exchange} using the API Sync feature available in {Studio} 7.4.0 or later.

* *Abbreviations:* Use wherever space is limited, such as for {ADesigner} project names, {MApp} names, and the like:
** SAPI for {SAPI}
** PAPI for {PAPI}
** EAPI for {EAPI}

* *Definition of Done:*
** Implementation meets all functional and nonfunctional requirements.
** Readiness endpoint checks liveness of all the {MApp}'s dependencies.
** {MUnit} tests assert all functional requirements and all tests pass.
** {FunMons} source code checked in to {SrcTFMon}.
** {MApp} deployed to all {CH} environments using {MVN} and scripts to invoke {MVN}.
** {FunMons} deployed for all {AP} environments and all statuses displayed in green.

=== {RAMLDefs} and {ADesigner} projects

* *{ADesigner} project*:
** Use a business-friendly project name, choose name of dominant RAML object and keep all other naming defaults:
*** Project name for {RAMLDef}: {PDSAPI}
**** {RAMLTitle}: {PDSAPI}
**** Defaults:
***** RAML file: {PDSAPII}.raml (visible in {APII})
***** {Exchange} asset ID: {PDSAPII}
***** {Exchange} name: {PDSAPI} (visible to all {Exchange} users)
*** Project name for {RAMLT} or {RAMLLib} containing that type: {PaymentApproval}
**** Type name: {PaymentApproval}
**** Defaults:
***** RAML file: {PaymentApprovalDerived}.raml
***** {Exchange} asset ID: {PaymentApprovalDerived}
***** {Exchange} name: {PaymentApproval} (visible to all {Exchange} users)
** Combine {RAMLT} with examples into a *{RAMLLib}*, don't just use a {RAMLT} fragment
** Use subdirectories within project:
*** For {RAMLT}: {TypesDir}
*** For examples: {ExamplesDir}

* *{APISpec} attributes:*
** {RAMLTitle}: {CIPAPI}, see above
** {RAMLVersion}: {APIV1}
** {RAMLBaseURI}: use the one from the {PRODEnv} environment, for example {CIPAPIStudEP}

=== {MApps}

* *Project-level:*
** {MVN} {MVNGroupIdElem}: {AAMVNGroupId}
** {Studio} project name = {MVN} {MVNArtifactIdElem} = {MVN} project name:
*** For {APII}: {PDSAPII} = {Exchange} asset ID of API exposed by that {APII}

* *{MFlows}:* {CADAAFlow}, {RPDFlow}
** Also correct names autogenerated by {Studio}
** *Prefer subflows* over flows where possible, for example, unless error handling or a message source is needed in the flow

* *Global config elements:*
** Use camelCase: {APIHTTPListConf}
** With the exception of global {EHandlers} (which are conceptually more like flows): {ApiErrorHandler}

* *{DocNameAttr}:*
** For event processors: sentence case without punctuation: "Set PNR from query param”
*** Such that the entire graphical representation of each flow reads as much as possible like a paragraph in a story
** For {SetVar} include the name of the variable and further detail only if really helpful) "origPayload"
** For {RaiseError} use the type of error being raised, omitting the {AppErrorNS} namespace but including all other namespaces
** For {FlowRef} use the name of the flow being invoked: {CADAAFlow}
*** Flow names should be descriptive already

* *File-level:*
** Use double quotes (") for XML attributes and single quotes for {DW} strings (so that an XML formatter can enforce XML file layout):
+
[source]
----
<set-payload
  value="#[output application/json --- {message: 'Invalid passenger name record given.'}]"
  doc:name="error" />
----
+
** {MFlowConfs}:
*** {ErrorXml} for global {EHandlers}
*** {GlobalXml} for global definitions that are not {EHandlers}
*** {ApiXml} for top-level, API-related {MFlows} called from {AKit}
*** {MainXml} for main integration logic (and additional {MFlowConfs} if helpful)
*** {HealthXml} for liveness and readiness endpoints (see below)
** Configuration properties files:
*** {PropYaml} for environment-independent config
*** {DevPropYaml}, {DevSecPropYaml} for env-dependent config for the {DEVEnv} environment

* *Endpoints:*
** Use *{HTTPPortProp}* or  *{HTTPSPortProp}* for the name of the configuration property that holds the port at which the {API} is exposed
** {API} endpoint for the one {API} exposed by an {APII}: /api/v1 for the {API} itself and /console/v1 for {AConsole} for that {API} (assuming major version v1)
** Health check endpoints: Mule apps expose endpoints for Kubernetes-style "probes":
*** For a liveness probe at {AliveUrlPath}, returning 200 if alive or 500 if not
*** For a readiness probe at {ReadyUrlPath}, returning 200 if ready or 500 if not
**** Readiness requires the Mule app to verify that all its dependencies are alive. For API dependencies, this means invoking {AliveUrlPath}
*** These should use the same {HTTPListConf} as the main {API} endpoints

* *Logging:*
** Merge two or more subsequent loggers into one
** Log-levels:
*** {INFOLevel} for start and end of externally visible flow, but not those delegated to by APIkit because they use Message Logging API policy
*** {INFOLevel} before and after every invocation of an external system
*** {INFOLevel} before raising error
*** {DEBUGLevel} for internal flows and other log entries

* *Error handling:*
** Use descriptive error types: {InvCheckInRespErr}
** By default, define all custom application error types in the {AppErrorNS} namespace
*** Omit that namespace in {DocNameAttr} and the like because it is assumed to be the most common namespace
** Define all custom application errors that should be communicated to a client (if possible) in the {ExtErrorNS} namespace and always supply description for client: {CantCheckinErr}, {BadReqErr} etc.
** Raise errors only for error conditions, not to control happy-path message processing
** Reuse common error response creation encapsulated in {ErrorCommXml} in {AppsComms}
*** Specially handles {BadReqErr} and all errors in the {ExtErrorNS} namespace

* *{MUnit} tests:*
** Do not test the {AKit}-generated main flow (containing the {AKit} Router) and console flow
** Do not test for validations already performed by {AKit}: required parameters, data types of parameters, payload message format, etc.
** Do not “enable flow sources” for HTTP/S and do not test {APIs} by invoking them over HTTP/S. Instead, refactor {MFlows} that do actual work so that they are easy to test and independent of {AKit}, and then test those flows directly
** In general, do not accept any incoming network communication and do not perform any outgoing network communication from unit tests: {MUnit} tests must run in isolation in a sandboxed {MR} without connectivity or dependency on remote components
** Use a synchronous logger configuration for tests, with all relevant log levels set to {DEBUGLevel}
** Testable {MFlows}:
*** Avoid nested XML elements in event processors: they can’t be mocked or spied on in {MUnit} tests. Instead, make them trivial so that they can’t fail

* *Functional Monitors:*
** To be implemented in code and checked in underneath {SrcTFMon} for each environment the {MApp} is deployed to

* *Reconnection strategies:*
** All global configurations for connectors that are likely to pool or cache connections ({DBConn}, {JMSConn}, etc.) should define a modest, finite reconnection strategy, such as reconnect 3 times with 1 second intervals. This then applies by default to all operations using this connector config and blocks the operation until completed
*** No other global connector configurations should define a reconnection strategy
*** Most connector operations require retry logic using {USS} and {TryS}, irrespective of any reconnection strategy
** All listeners should define {ReconnForever} with a realistic interval locally to the listener itself, thereby overriding any globally defined reconnection strategy
*** The only exception is listeners that cannot realistically re-establish connectivity once lost, such as {HTTPList}

* *General:*
** Avoid absolute file system paths in {MApps} if at all possible; most often, a relative path suffices
*** Relative paths do not work for the sslrootcert in the PostgreSQL JDBC URL
** Reconnection strategies: Do not fail deployment when backend systems are down, and don’t retry forever as this blocks requests when the backend system is down
** Use {ChoiceR} for content-based routing, not to validate dynamic data
** Use the {ValMod} validators to validate dynamic data and specifically to enforce invariants, preconditions, postconditions, assertions, expected service responses, and the like
*** Raise descriptive custom application errors from within the validators (by error mapping all errors to such a custom error)

=== {CH} deployments

* *{CH} deployment names:*
** {FMSAPIIDevHost} for a {MApp} called {FMSAPII} deployed to the {DEVEnv} environment
** {FMSAPIIProdHost} for the same {MApp} deployed to the {PRODEnv} environment

=== {AManager}

* Use *{AAPolicies}* as much as possible, instead of repetitively defining the same policies on every {APIInst}
* Set the *consumer endpoint* of every {APIInst} to the correct endpoint URL of the {CH} deployment of the {APII} in that environment: {FMSAPIDevEPComplete} for {FMSAPI} in {DEVEnv} environment

=== {FunMons}

* *{FunMons} names* and *asset IDs*:
** {FMSAPIIDevFunMon} for {FMSAPII} in {DEVEnv}
** {FMSAPIIProdFunMon} for the same {MApp} in {PRODEnv} (which exposes its {API} on {FMSAPIProdEPComplete})
* {FunMons} must execute in a *different CloudHub/AWS region* than the {MApp} they are monitoring is deployed to: {CHRegionUSE2} if {MApp} runs in {CHRegionUSE1}
* Report violations by posting to appropriate *Slack channel* via webhook
* For any {MApp} that supports it, {FunMons} should invoke the *liveness and readiness endpoints* exposed by that Mule app
* For {EAPIs}, {FunMons} should also invoke a real, read-only business transaction that exercises as many nodes in the {AN} as possible

=== {AMQ}

* Consider *encrypting* messages in {PRODEnv} but not in {DEVEnv} and {TESTEnv}
* Every "normal" {AMQQ} should be associated with a *{DLQ}*, the {TTL} of which should be as long as possible (currently 14 days)

* *{AMQX} names:*
** {CancelledFXDev} for an {AMQX} in the {DEVEnv} environment
** {CancelledFX} for the equivalent {AMQX} in the {PRODEnv} environment
*** Note that technically the same name could be used in all environments

* *{AMQQ} and corresponding {DLQ} names:*
** {CancelledFQDev} for an {AMQQ} in {DEVEnv}
** {CancelledFQ} for the equivalent {AMQQ} in {PRODEnv}
*** Note that technically the same name could be used in all environments
** {CancelledFDLQ} for the {DLQ} belonging to {CancelledFQ} (and therefore in {PRODEnv})
