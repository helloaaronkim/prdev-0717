// Copyright (C) MuleSoft, Inc. All rights reserved. http://www.mulesoft.com
//
// The software in this package is published under the terms of the
// Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License,
// a copy of which has been included with this distribution in the LICENSE.txt file.
[[module-operational-concerns]]
:sectnums!:
== {M-c} {mct}: Developing for Operational Concerns

{InThisMYou} improve operational observability by implementing operational logging and monitorability of {MApps} and applying the previous non-redundancy of code principle to implement a reusable health check library for {MApps}.

{MOBJ}

* Implement operational logging
* Expose health check endpoints and monitor a {MApp} from {AP}
* Extract reusable {MApp} code into a library
* Extract reusable error handling and health check code into a library

//....................................................................................................................
<<<
:sectnums!:
[[wt-begin-131]]
=== {WT-c} {mct}-{counter:wtct}: Implement operational logging

Logging should add minimal performance overhead to production operation yet provide enough context or information for traceability.

{InThisWTYou} tune the {L4J} configuration generated by {Studio} for performance and enrich logging messages for traceability using the {TracMod} and logging variables.

{YouWill}

* <<Use asynchronous logging in production and synchronous logging at {DEBUGLevel} level in unit tests>>.
* <<Enrich logging with Mapped Diagnostic Context and logging variables>>.

==== Solution file
{YouSeeSol} {SolDir131}.

==== Starting file
{YouMightNeedStarter} {SolDir124}.

==== Use asynchronous logging in production and synchronous logging at {DEBUGLevel} level in unit tests

{InThisWTSecYou} inspect and tune the {L4J} configuration generated by {Studio} when you created {CIPAPII}. You must ensure that logging in {PRODEnv} is asynchronous, so that it adds minimal latency to normal event processing. On the other hand, when running unit tests it is convenient to use synchronous logging, and so you change {L4JTXml} to a synchronous configuration. Also, log entries written by unit tests should typically be down to {DEBUGLevel} level, which would add prohibitive overhead in production.

. *Study log configs:* Inspect *{L4JXml}* and *{L4JTXml}*, the former is used in all normal deployments, while the latter is used only when running unit — such as, {MUnit} — tests; note that with the exception of the log appender (file versus console), both log configurations are essentially identical and perform logging asynchronously.
. *Tune test log config:* Change *{L4JTXml}* to use *synchronous* logging and show {DEBUGLevel} log entries created by the *default logger*, and the *{MsgLog}* {APolicy}:
+
--
.{L4JTXml} of {CIPAPII}
[source]
----
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%-5p %d [%t] %c: %m%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Root level="INFO">
      <AppenderRef ref="Console"/>
    </Root>
    ...
    <Logger
      name="org.mule.runtime.core.internal.processor.LoggerMessageProcessor"
      level="DEBUG" />
    <Logger
      name="org.mule.runtime.logging"
      level="DEBUG" />
  </Loggers>
</Configuration>
----

{NOTE} _The default logger, and {MsgLog} {APolicy} all use different loggers/categories._

{NOTE} _You will see this synchronous logging configuration in action when you run {MUnit} tests in a later {WT}._
--
+
. *Study or tune log config:* In *{L4JXml}*, you need to make no changes, as the configuration is already asynchronous, but you may want to bring the structure of this file in line with the structure of {L4JTXml}. Similarly, you may apply {MVN} resource filtering to reuse the {MVN} configuration in the log filename configuration:
+
.{L4JXml} of {CIPAPII}
[source]
----
<Configuration status="WARN">
  <Appenders>
    <RollingFile name="File"
      fileName="${sys:mule.home}${sys:file.separator}logs${sys:file.separator}${project.name}.log"
      filePattern="${sys:mule.home}${sys:file.separator}logs${sys:file.separator}${project.name}-%i.log">
      <PatternLayout pattern="%-5p %d [%t] [event: %X{correlationId}] %c: %m%n"/>
      <SizeBasedTriggeringPolicy size="10 MB"/>
      <DefaultRolloverStrategy max="10"/>
    </RollingFile>
  </Appenders>
  <Loggers>
    <AsyncRoot level="INFO">
      <AppenderRef ref="File"/>
    </AsyncRoot>
    ...
    <AsyncLogger
      name="org.mule.runtime.core.internal.processor.LoggerMessageProcessor"
      level="INFO" />
    <AsyncLogger
      name="org.mule.runtime.logging"
      level="INFO" />
  </Loggers>
</Configuration>
----

==== Enrich logging with Mapped Diagnostic Context and logging variables

{InThisWTSecYou} inspect and configure the {L4J} configuration generated by {Studio} and add a new {TracMod} to {CIPAPII} that allows you to enrich log messages automatically by adding variables to the logging context for a given Mule event.

[start=4]
. *Study log configs:* Inspect *{L4JXml}* and note the existing *File* appender and the pattern layout that currently logs the *correlationId*.
. *Configure MDC config:* Change *{L4JXml}*, updating the *PatternLayout* for the existing *File* appender and temporarily adding a new *Console* appender with the same PatternLayout that instructs Mule to automatically add the MDC context:
+
--
.{L4JXml} of {CIPAPII}
[source]
----
<Configuration status="WARN">
  <Appenders>
    <RollingFile name="File">
      <PatternLayout pattern="%-5p %d [%t] [%MDC] %c: %m%n"/>
    </RollingFile>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%-5p %d [%t] [%MDC] %c: %m%n"/>
    </Console>
  </Appenders>
  <Loggers>
    ...
    <AsyncRoot level="INFO">
      <AppenderRef ref="File"/>
      <AppenderRef ref="Console"/>
      ...
    </AsyncRoot>
  </Loggers>
</Configuration>
----

{NOTE} _By default, Mule logs two MDC entries: processor, which shows the location of the current event, and event, which shows the correlation ID of the event._

{NOTE} _The Console appender is only used to make the log context available in the {Studio} console. This is not advised for production environments._

{NOTE} _The {Studio} console is not completely controlled by the *{L4JXml}*. {Studio} itself only uses part of the *{L4JXml}* and does not use the configuration defined in the File appender. The full log file created by the File appender can be found by navigating to the <MULE_HOME>/logs directory of the {Studio} embedded {MR}. You can find the MULE_HOME location by searching for MULE_HOME in a running {Studio} console_
--
+
. *Add managed library dependency:* Locate the existing dependency management of {TracArtifactId} in the *{BOM}* and add a matching entry to the {CIPAPII} *{POM}*:
+
--
.{POMXml} of {CIPAPII}
[source]
----
<dependencies>
  ...
  <dependency>
    <groupId>org.mule.modules</groupId>
    <artifactId>mule-tracing-module</artifactId>
    <classifier>mule-plugin</classifier>
  </dependency>
</dependencies>
----
--
+
. *Add logging variables to the context:* add a logging variable at the beginning of *{CIByPNRFlow}* for {PNR}:
+
--
.{MainXml} of {CIPAPII}
[source]
----
<flow name="check-in-by-pnr">
  <tracing:set-logging-variable variableName="PNR" value="#[vars.PNR default '']"/>
  ...
</flow>
----

{NOTE} _The {TracMod} enables you to enhance your logs by adding, removing, and clearing variables from the logging context for a given Mule event._

{NOTE} _This logging context affects any output of a Logger component and any internal logging that the {MR} produces. Therefore, you can add more context to the event that Mule is processing if you need additional information for tracking down any potential issue, for example, when an unexpected error occurs._

{NOTE} _The logging context exists for the entire execution of the corresponding event. Once a variable is set, it will continue to be logged for an event until it is removed using the corresponding remove operation or until all variables are removed using the clear operation._
--
+
. *{RUNINVLOG}* Run the {MApp} from {Studio} and invoke the {API} via {cURL} as before and study the log entries noting the *correlationId* and the new variables set in the logging context.


:sectnums:
//....................................................................................................................

//....................................................................................................................
<<<
:sectnums!:
[[wt-begin-132]]
=== {WT-c} {mct}-{counter:wtct}: Expose and monitor health check endpoints

It is common practice that {MApps} should expose health check endpoints that can be invoked from the outside to probe the functioning of the {MApp}.
{CH} adds such health checks for its own purposes, to drive automated restart of {MApps}, for instance, but these health checks are only available when deploying to {CH} and are generic, that is, without knowledge of any implementation details of a {MApp}.

An independent but related concern is that {MApps} should also be represented in the graphical {AN} view provided by {AVis}, and show up in the correct architecture layer, following {Aled}.

{InThisWTYou} add two types of health check endpoints to {CIPAPII}, following a convention used, for example, by {K8s}: Firstly, a liveness endpoint that can be invoked over HTTP/S to perform a liveness check of the {MApp}. {MApps} that fail the liveness check are not in a runnable state and should be restarted. Secondly, a readiness endpoint that can be invoked over HTTP/S to perform readiness checks of the {MApp}. {MApps} that fail the readiness check but not the liveness check are themselves running fine, but at least one of their required downstream dependencies — such as an {API} invoked by the {MApp} — is not ready. Restarting such a {MApp} is pointless, but it is nevertheless not ready to service requests. Furthermore, you extend {CIPAPII} and the {MVN} build to assign {MApps} to the correct architectural layer in {AVis} and have {AVis} use a concise name for the {MApp}.

{YouWill}

* <<Expose liveness and readiness endpoints>>.
* <<Make a {MApp} announce its tier and concise name to {AVis}>>.
* <<Configure a {FunMon} to invoke health check endpoints>>.

==== Solution file
{YouSeeSol} {SolDir132}.

==== Starting file
{YouMightNeedStarter} {SolDir131}.

==== Expose liveness and readiness endpoints

{InThisWTSecYou} add healtheck endpoints in the form of a liveness and a rudimentary readiness endpoint to {CIPAPII}, using the same {HTTPListConf} also used for exposing {CIPAPI}. These health check endpoints respond to a HTTP GET with a HTTP 200 response (and a payload of UP) in case all is well, or a HTTP 500 response (and a payload of DOWN) if not.

. *Create {MFlowConf}:* In {Studio}, add to {CIPAPII} a {MFlowConf} *{HealthXml}*.
. *Implement liveness endpoint:* Add to {HealthXml} a new {MFlow} *{ApiAliveFlow}* for the liveness endpoint, referring to the same {HTTPListConf} that is also used to expose the {API}, using a path of *{AliveUrlPath}* and setting the response to 200 and UP under normal conditions, or 500 and DOWN in case of error:
+
--
.{HealthXml} of {CIPAPII}
[source]
----
<flow name="api-alive">
  <http:listener config-ref="apiHttpListenerConfig" path="/alive">
    <http:response statusCode="200" />
    <http:error-response statusCode="500">
      <http:body>DOWN</http:body>
    </http:error-response>
  </http:listener>
  <set-payload value="UP" />
</flow>
----

{NOTE} _Using the same {HTTPListConf} for the health check endpoints as for exposing the {API} makes the health checks more meaningful._

{NOTE} _health check endpoints are not part of the business-centric {API} defined in an {APISpec} and therefore listen to an endpoint and path not covered by the {APISpec}._

{NOTE} _It is difficult to construct a scenario where the above liveness endpoint implementation would return the configured error response._
--
+
. *Implement readiness endpoint:* Add to {HealthXml} a new {MFlows} *{ApiReadyFlow}* for the readiness endpoint, which for the time being does not have any downstream dependencies to check:
+
--
.{HealthXml} of {CIPAPII}
[source]
----
<flow name="api-ready">
  <http:listener config-ref="apiHttpListenerConfig" path="/ready">
    <http:response statusCode="200" />
    <http:error-response statusCode="500">
      <http:body>DOWN</http:body>
    </http:error-response>
  </http:listener>
  <flow-ref name="check-all-dependencies-are-alive" />
  <set-payload value="UP" />
</flow>

<sub-flow name="check-all-dependencies-are-alive">
  <logger />
</sub-flow>
----

{NOTE} _{MFlows} are not allowed to be empty, so to make {CADAAFlow} valid you add an empty logger._
--
+
. *{RUNINV}* Run the {MApp} from {Studio} and invoke the health check endpoints; this should return a HTTP 200 response with UP in both cases:
+
--
include::{LocalCurlHealthLocal}[]
--

==== Make a {MApp} announce its tier and concise name to {AVis}

{InThisWTSecYou} extend the {MVN} build to set a Java system property that informs {AVis} to which tier a given {MApp} belongs. You assign {CIPAPII} to the {AVisPLayer} tier. {AVis} calls tiers layers and predefines the {AVisELayer}, {AVisPLayer}, and {AVisSLayer} layers.

By default, {AVis} uses the {CH} application name of a {CH}-deployed {MApp} (such as {CIPAPIStudHostDev}) to represent that {MApp} in its {AN} rendering. This is slightly longer than required and hence makes {AVis} renderings unnecessarily busy: you tell {AVis} to use a more concise display name for {CIPAPII} by setting a Java system property.

[start=5]
. *Add {AVis} props to {CH} deployment config:* To the *{PPOM}* add to the *{MMP}* configuration three properties, one for setting the {AVis} layer, one for setting the {AVis} display name, and another one to allow the {AP} control plane to collect relevant runtime analytics:
+
--
.{PPOMXml}
[source]
----
<cloudhub2Deployment>
  ...
  <properties>
    <anypoint.platform.config.analytics.agent.enabled>
      true
    </anypoint.platform.config.analytics.agent.enabled>
    <anypoint.platform.visualizer.displayName>
      ${project.name}
    </anypoint.platform.visualizer.displayName>
    <anypoint.platform.visualizer.layer>
      ${api.layer}
    </anypoint.platform.visualizer.layer>
    ...
  </properties>
  ...
</cloudhub2Deployment>
----

{NOTE} _The collection of runtime analytics may already be enabled for the {CH} image you are deploying to, so the above is not always strictly necessary. But it is highly recommended._

{NOTE} _With this, {AVis} will render any {MApp} using the {MVNArtifactIdElem} of the child project (such as {CIPAPII}) rather than the {CH} application name (such as {CIPAPIStudHostDev}). The former is sufficient because {AVis} only displays the {AN} for a given {APOrg}._

{NOTE} _This configuration relies on the {ApiLayer} property, which is fixed for every {MApp}._
--
+
. *Define layer name props:* To the *{PPOM}* add top-level properties that fix the allowed layer names:
+
--
.{PPOMXml}
[source]
----
<project>
	...
	<name>solutions-parent-pom</name>
  <properties>
    <api.layer.eapi>Experience</api.layer.eapi>
    <api.layer.papi>Process</api.layer.papi>
    <api.layer.sapi>System</api.layer.sapi>
    <api.layer.backend>Backend</api.layer.backend>
    <api.layer.none>None</api.layer.none>
    ...
  </properties>
</project>
----

{NOTE} _The values {AVisELayer}, {AVisPLayer}, and {AVisSLayer} are well-known to {AVis}, but {AVis} accepts arbtirary layer names, such as {AVisBELayer}._

{NOTE} _These properties are available to all child {POMs}/projects._
--
+
. *Set layer prop:* In the *{POM}* for {CIPAPII}, set the value of the *{ApiLayer}* property, such that it is available in the {MMP} configuration in the {PPOM}:
+
--
.{POMXml} of {CIPAPII}
[source]
----
<properties>
  ...
  <api.layer>${api.layer.papi}</api.layer>
</properties>
----

{NOTE} _Because the layer name is taken from a property inherited from the {PPOM}, it reduces redundancy and the risk of typos._
--
+
. *Bump {MVN} artifact version:* In *{POMXml}*, bump the patch version of {CIPAPII}:
+
--
.{POMXml} of {CIPAPII}
[source]
----
...
<version>1.0.2</version>
...
----
--
+
. *{BUILDDEPLOY}* In a {CLI}, deploy the application to {Exchange} and subsequently the {CH} *{DEVEnv}* environment using the {MMP}, supplying the same command-line arguments as before; this should result in a successful deployment:
+
--
include::{DeployCIPAPIIExchange}[]

[source,bash,subs="attributes+"]
----
mvn -DmuleDeploy deploy -Dap.client_id=<insert-your-client-id> -Dap.client_secret=<insert-your-client-secret> -Dap.ca.client_id=<insert-your-ca-client-id> -Dap.ca.client_secret=<insert-your-ca-client-secret> -Dencrypt.key={EncKeyVal} -Ddeployment.env=dev
----
--
+
. *{INV}* Invoke the health check endpoints; this should return a HTTP 200 response in both cases:
+
--
[source,bash,subs="attributes+"]
----
curl -i {CIPAPIStudBase}/alive
----

[source,bash,subs="attributes+"]
----
curl -i {CIPAPIStudBase}/ready
----

{NOTE} _The hostname will be different for you._
--
+
. *Check {AVis} layer:* In {AVis}, under {SandboxEnv} environments, confirm that {CIPAPII} in the {DEVEnv} environment is indeed assigned to the {AVisPLayer} layer.
+
{NOTE} _It can take several minutes for {AVis} to reflect the latest configuration._

==== Configure a {FunMon} to invoke health check endpoints

{InThisMYou} — using an account with sufficient entitlements, or an instructor, create a {FunMon} in {AMon} to implement a liveness and readiness probe on {CIPAPII}. The {FunMon} sends HTTP GET requests on a regular basis to {CIPAPII} and raises an alert if either fails. This is a licensed feature that is not available with trial accounts, which is why you must have an account with sufficient entitlements or demonstrated by an instructor.

[start=12]
. *Navigate to {AMon}:* Using credentials with sufficient permissions, log in an organization with sufficient entitlements or as instructor to the {AA} {APOrg} and navigate to {AMon}.
. *Create {FunMon}:* Create a {FunMon} for *{CIPAPII}* in the {DEVEnv} environment sending an HTTP *GET* request every *15 minutes* your {CH} deployed {CIPAPII} endpoint, asserting that the HTTP status is *200* and notifying you via *email* to your email address of any failures.
+
{NOTE} _You can switch to the code editor, to create a monitor written in BAT, a Behavior Driven Development (BDD) language._

{NOTE} _Additionally, you can upload custom test suites written in BAT via the {AP} {APIs}._

:sectnums:
//....................................................................................................................

//....................................................................................................................
<<<
:sectnums!:
[[wt-begin-133]]
=== {WT-c} {mct}-{counter:wtct}: Extract reusable {MApp} code into a library

Reflecting on the {CIPAPII} {MApp} code, it becomes apparent that parts of it are likely to be re-usable in other similar {MApps} and {APIIs}. Examples are the global {EHandlers} in {ErrorXml} and all of the health check endpoints in their current form in {HealthXml}. In future {WTs} you will identify other reusable {MFlows} or configuration elements.

{InThisWTYou} extract reusable {MApp} code from {CIPAPII} into a separate project {AppsComms}, which builds a {LibMPlugin}, that can be imported into any {MApp} that needs this functionality. The {AppsComms} project is the first of many projects that can reuse parts of the {MVN} build configuration encapsulated in the {PPOM} and {BOM}.

{YouWill}

* <<Identify reusable {MApp} code elements>>.
* <<Extract reusable {MApp} flows and configuration elements into a new {MVN} project>>.
* <<Import {MApp} code elements from a library>>.
* <<Deploy {MVN} artifacts to {Exchange} as custom assets>>.

==== Solution file
{YouSeeSol} {SolDir133}.

==== Starting file
{YouMightNeedStarter} {SolDir132}.

==== Identify reusable {MApp} code elements

{InThisWTSecYou} inspect {CIPAPII} and identify code elements that could be reused by other, similar {MApps}.

. *{THINK}* In {Studio}, inspect *{ErrorXml}* and think on how the global {EHandlers} therein were created and under what circumstances they could be reused in other {MApps}.
. *{THINK}* Inspect *{HealthXml}* and think on how {ApiAliveFlow} and {ApiReadyFlow} differ between {CIPAPII} and other similar {MApps}.

[[wt3-3-extract-config-into-lib]]
==== Extract reusable {MApp} flows and configuration elements into a new {MVN} project

{InThisWTSecYou} create a new {MVN} project {AppsComms} with the code from {ErrorXml} and {HealthXml} in {CIPAPII}. The {AppsComms} {MVN} project is structured like a {MApp}, with {MFlowConfs} in {SrcMM}, but builds an artifact with {MVN} classifier {MPluginClassifier}. This type of {MPlugin} could be called a "{LibMPlugin}" to distinguish it from other, more sophisticated {MPlugins} like connectors or {XMLSDKMods} — all of which use the {MVN} classifier {MPluginClassifier}. By contrast, a {LibMPlugin} just contains simple resources like {MFlowConfs} and is built from a {MVN} project with {MVNPackElem} {MAppMVNPack} and {MVNClassElem} {MPluginClassifier}.

[start=3]
. *Create new library project:* In {Studio}, create a new standard {MApp} project named *{AppsComms}*; this creates the {AppsComms} project directory in your {Studio} workspace directory.
. *Delete auto-created {MFlowConf}:* Delete the {MFlowConf} automatically created by {Studio} in the new {AppsComms} project.
. *Copy reusable {MFlowConfs}:* In a {CLI} or {Studio}, copy the previously identified reusable {MFlowConfs} from {CIPAPII} to {AppsComms}, appending *{CommSuffix}* to their filenames:
+
--
[source,bash,subs="attributes+"]
----
cd ${WSEnvVar}
cp {CIPAPII}/{SrcMM}/health.xml  {AppsComms}/{SrcMM}/health-common.xml
cp {CIPAPII}/{SrcMM}/error.xml  {AppsComms}/{SrcMM}/error-common.xml
----

{NOTE} _By convention, you append {CommSuffix} to all {MFlowConfs} in {AppsComms}, so that these filenames are unlikely to conflict with filenames in any {MApp} that includes {AppsComms}._

{NOTE} _{Studio} might show an error that the {HTTPListConf} used in {HealthCommXml} is missing. This will be corrected shortly._
--
+
. *Adapt {POM}:* Change the {POMXml} of {AppsComms} into a {CPOM} by defining *{PPOMXml}* as its {PPOM}, adapting the {MVNCoords} to match the *groupId* of your {APOrg} ID, removing *repositories* and adding the *{MMP} configuration* to create an artifact with {MVNClassElem} *{MPluginClassifier}*:
+
--
.{POMXml} of {AppsComms}
[source]
----
include::{LocalSolDir133}/{AppsComms}/{POMXml}[tags={AllTag}]
----
{NOTE} _You must ensure to remove the repository definitions as they will conflict with the {BOM} and cause deployment failures later._

{NOTE} _This {POM} uses the {APOrg} ID for the groupId, as this is a prerequisite for publishing to {Exchange}, which you will do later._

{NOTE} _The {MVNPackElem} element remains {MAppMVNPack} but the supplied {MMP} configuration changes the created artifact to be a {MPlugin} via the {MVNClassElem} element._

{NOTE} _The {MMP} configuration is inherited in its entirety from the {PPOM}, and only the {MVNClassElem} value is overridden in this {CPOM}._

{NOTE} _The {MFlowConfs} in {AppsComms} — and therefore {AppsComms} itself — currently depend on the {HTTPConn}, just like {CIPAPII} from which they originate. You make this fact explicit by defining these two dependencies in provided scope, meaning they must be provided (packaged) by all {MApps} that include {AppsComms}. To define these dependencies, you make use of the already configured version management in the {BOM}._
--
+
. *Remove non-reusable flow:* In {Studio}, open *{HealthCommXml}* and cut *{CADAAFlow}* because this {MFlow} cannot be implemented in a common library; {Studio} should now show an error that this {MFlow} is invoked from a {FlowRef} in {ApiReadyFlow} but missing.
. *Create stubs:* Create a new {MFlowConf} called *{StubsXml}* in *{SrcTR}* (drag it from {SrcMM} if necessary) that contains stubs (placeholders) for configuration elements expected to exist in the including {MApp} but missing from {AppsComms}, paste *{CADAAFlow}* into it, and add a placeholder {HTTPListConf}:
+
--
.{StubsXml} of {AppsComms}
[source]
----
<http:listener-config name="apiHttpListenerConfig">
  <http:listener-connection host="0.0.0.0" protocol="HTTP" port="8081" />
</http:listener-config>

<sub-flow name="check-all-dependencies-are-alive">
  <logger />
</sub-flow>
----

{NOTE} _The {StubsXml} file is in the test source branch and is therefore available at development time but is not packaged in the resulting {AppsComms} library. This serves merely to eliminate the error(s) shown in {Studio}._

{NOTE} _The details of these configuration elements do not matter, only their type and name. They will never be instantiated._
--
+
. *{BUILD}* Navigate to the base directory of {AppsComms} and run a {MVN} build to install {AppsComms} into your local {MVN} repo; this should succeed:
+
--
include::{LocalBuildAppsComms}[]

{NOTE} _Installing {AppsComms} into your local {MVN} repository with this statement is essential, otherwise {MVN} will not be able to resolve dependencies to {AppsComms} in later {WTs}._
--
+
. *Install {PPOMs}:* Install the *{BOM}* and *{PPOM}* used by {AppsComms} and {CIPAPII} into your local {MVN} repository:
+
--
include::{LocalInstPPOMs}[]

{NOTE} _This is necessary because the {POM} of {AppsComms} depends on both the {PPOM} and {BOM}, yet in the previous step only {AppsComms} was installed into the local {MVN} repository. When a dependency on {AppsComms} is resolved, the {POM} of {AppsComms} is loaded from the local {MVN} repo, and so the {PPOM} and {BOM} — which are required to interpret the {POM} of {AppsComms} — must also be loaded from the local {MVN} repo._
--

==== Import {MApp} code elements from a library

{InThisWTSecYou} import {AppsComms} as a {MVN} dependency into {CIPAPII} to reuse the {MApp} code from that library.

[start=11]
. *Add managed library dependency:* Locate the existing dependency management of {AppsComms} in the *{BOM}* and add a matching entry to the {CIPAPII} *{POM}*:
+
--
.{POMXml} of {CIPAPII}
[source]
----
<dependencies>
  ...
  <dependency>
    <groupId>${student.deployment.ap.orgid}</groupId>
    <artifactId>apps-commons</artifactId>
    <classifier>mule-plugin</classifier>
  </dependency>
</dependencies>
----

{NOTE} _The {BOM} defines a {MVN} property, available in all {CPOMs}, to hold your {APOrg} ID, which is the {MVNGroupIdElem} for the {AppsComms} retrieved from the {Exchange} of that {APOrg}._
--
+
. *Refresh {Studio} project:* In {Studio}, close and reopen the *{CIPAPII}* project; {Studio} should resolve the {AppsComms} dependency and show it as a project dependency.
+
--
{NOTE} _If {Studio} does not find {AppsComms} then you may need to force reloading {MVN} dependencies from a {CLI} with the `-U` option, and then close and reopen the {CIPAPII} {Studio} project:_

[source,bash]
----
mvn clean verify -U
----
--
+
. *Replace {EHandlers} with import:* In *{ErrorXml}* of {CIPAPII} replace the code that has been extracted to {AppsComms} — which is all {MApp} code in that file — with an import of the relevant {MFlowConf} from {AppsComms}:
+
--
.{ErrorXml} of {CIPAPII}
[source]
----
<mule>
  <import file="error-common.xml" />
</mule>
----

{NOTE} _Do not delete the XML namespace-related attributes from the root element in this {MFlowConf} — they are omitted here just for brevity!_

{NOTE} _{MFlowConfs} from the {MApp} itself are always implicitly available in that {MApp}, but files packaged in a library must be imported explicitly, such as here._
--
+
. *Replace health check endpoints with import:* In *{HealthXml}* of {CIPAPII} replace the code that has been extracted to {AppsComms} with an import of the relevant {MFlowConf} from {AppsComms}:
+
--
.{HealthXml} of {CIPAPII}
[source]
----
<mule>
  <import file="health-common.xml" />

  <sub-flow name="check-all-dependencies-are-alive">
    <logger />
  </sub-flow>
</mule>
----

{NOTE} _Do not delete the XML namespace-related attributes from the root element in this {MFlowConf} — they are omitted here just for brevity!_

{NOTE} _The {CADAAFlow} {MFlow} inoked from {ApiReadyFlow} in {AppsComms} but missing from that library must be implemented in {HealthXml}, otherwise {CIPAPII} would fail at runtime and {Studio} should also show an error at development time._
--
+
. *{RUNINV}* Run the {MApp} from {Studio} and invoke the health check endpoints; this should return a HTTP 200 response in both cases:
+
--
include::{LocalCurlHealthLocal}[]
--

==== Deploy {MVN} artifacts to {Exchange} as custom assets

Mule 4 Extensions that declare dependencies that don’t exist in Maven Central or the MuleSoft Maven repositories, are not currently supported. Therefore any extension type artifact deployed to {Exchange} that relies on a custom asset such as the {PPOM} and {BOM} introduced in the previous sections, are required to deployed to {Exchange} prior. 

The steps to publish an asset with Maven are slightly different for each asset type, and different assets use different Maven plugins. In this case you will use {EMMP} each {POM} as a custom asset.

[start=16]
. *Study {BOM}:* Browse the content of the {BOMXml}, identifying the *{EMMP}* configuration located in a Maven profile *deploy-to-exchange-v3*:
+
--
.{BOMXml}
[source]
----
include::{LocalSolDir133}/{BOMXml}[tags={EMMPConfigTag}]
----

{NOTE} _The exchange-pre-deploy goal must be run to pre-validate the asset with {Exchange} where it checks various pre-conditions such as unique asset versions. Without explicitly running this goal, the {Exchange} API will return a status code of 412 (Precondition Failed). It can be bound to other phases such as the validate phase, but it is set to the deploy phase in this course to not interfere with local builds._

{NOTE} _This plugin is applied directly to the {BOM} and configured not to be inherited by {MVN} child projects so that the {Exchange} pre-validation steps are not applied to projects that will not be deployed to {Exchange}._

{NOTE} _The {Exchange} Maven Facade API does not support dynamic parameters within groupIds such as ${aa.ap.org.id} and it requires the value to be the hardcoded {APOrg} ID._

{NOTE} _The {Exchange} Maven Facade API requires that every asset deployed must have an artifact name element defined in the {POM}._

{NOTE} _The {Exchange} Maven Facade API requires a {MVN} property named type with the value set custom for custom assets._
--
+
. *Add {MVN} property to {PPOMs}:* Add to the {PPOMs} a property to instruct the {EMMP} plugin that this is a custom asset:
+
--
.{BOMXml}
[source]
----
...
<properties>
  ...
  <type>custom</type>
  ...
<properties>
...
----

.{PPOMXml}
[source]
----
...
<properties>
  ...
  <type>custom</type>
  ...
<properties>
...
----

{NOTE} _This property is not explicitly used but is used internally by the {EMMP} and needed for deployment to {Exchange}, otherwise {Exchange} cannot determine the asset type._
--
. *Deploy {PPOMs} to {Exchange}:* Deploy the *{BOM}* and *{PPOM}* used by {AppsComms} to your remote {Exchange} repository:
+
--
include::{DeployPPOMs}[]

{NOTE} _When a SNAPSHOT version is deployed to {Exchange}, it is created in the development lifecycle phase allowing the asset version to be overwritten and permanently deleted, whenever. When a stable asset version is deployed, {Exchange} will treat the asset as a production asset and enforce the standard {Exchange} rules upon it. Such as locking the version number so it cannot be overwritten and only allowing permanent deletion within the first 7 days._
--
+
. *Deploy custom library to {Exchange}:* Deploy {AppsComms} to your remote {Exchange} repository:
+
--
include::{DeployAppsComms}[]

{NOTE} _The {MMP} is automatically integrated with {EMMP}, therefore there is no need to define the {EMMP} configuration as well. It is only needed to directly reference the {EMMP} when deploying non-Mule artifacts such as custom libraries and {POMs}. If both are configured, deployment will happen twice, and the second deployment will fail with a conflict._

{NOTE} _The {Exchange} Maven Facade API enables you to both create your asset and set the mutable data describing it in the same request. The mutable data of an asset includes tags, custom fields, categories, and documentation pages. The final solution includes a complete example of creating a {APolicy} with documentation and tags._
--
+
. *Refresh {Studio} project:* In {Studio}, close and reopen the *{CIPAPII}* project; {Studio} should resolve the {AppsComms} dependency and show it as a project dependency.
+
--
{NOTE} _If {Studio} does not find {AppsComms} then you may need to force reloading {MVN} dependencies from a {CLI} with the `-U` option, and then close and reopen the {CIPAPII} {Studio} project:_

[source,bash]
----
mvn clean verify -U
----
--

:sectnums:
//....................................................................................................................
